# -*- coding: utf-8 -*-

"""
/***************************************************************************
 ProgramacaoAplicadaGrupo3
                                 A QGIS plugin
 Solução do Grupo 3
 Generated by Plugin Builder: http://g-sherman.github.io/Qgis-Plugin-Builder/
                              -------------------
        begin                : 2023-05-07
        copyright            : (C) 2023 by Grupo 3
        email                : matheus.silva@ime.eb.br
                               samuel.melo@ime.eb.br
                               reginaldo.filho@ime.eb.br
                               romeu.peris@ime.eb.br
 ***************************************************************************/

/***************************************************************************
 *                                                                         *
 *   This program is free software; you can redistribute it and/or modify  *
 *   it under the terms of the GNU General Public License as published by  *
 *   the Free Software Foundation; either version 2 of the License, or     *
 *   (at your option) any later version.                                   *
 *                                                                         *
 ***************************************************************************/
"""

__author__ = 'Grupo 3'
__date__ = '2023-03-20'
__copyright__ = '(C) 2023 by Grupo 3'

# This will get replaced with a git SHA1 when you do a git archive

__revision__ = '$Format:%H$'

from qgis.PyQt.QtCore import QCoreApplication, QVariant
from qgis.core import (QgsProcessing,
                       QgsFeatureSink,
                       QgsWkbTypes,
                       QgsProcessingMultiStepFeedback,
                       QgsField,
                       QgsSpatialIndex,
                       QgsFeature,
                       QgsProcessingException,
                       QgsProcessingAlgorithm,
                       QgsGeometry,
                       QgsFields,
                       QgsProcessingParameterFeatureSource,
                       QgsProcessingParameterFeatureSink)


class Projeto2Solucao(QgsProcessingAlgorithm):
    """
    Esse projeto tem por objetivo verificar as drenagens com sentido incorreto, drenagens que iniciam
    em sumidouro, drenagens que terminam em vertedouros, drenagens que iniciam no oceano, massas d'água
    com/sem fluxo sem/com drenagem interna, canal linha sem drenagem coincidentes e por fim vertedouros e 
    sumidouros devem estar relacionados com uma drenagem.
    """

    # Declarando os parâmetros que serão utilizados, como a flag que será retornado,
    # a drenagem, o canal, o vertedouro e sumidouro e por fim as massas d'água.

    FLAGS = 'FLAGS'
    FLAGS_LINHA = 'FLAGS_LINHA'
    FLAGS_POLIGONO = 'FLAGS_POLIGONO'
    INPUT_DRENAGEM = 'INPUT_DRENAGEM'
    INPUT_CANAL = 'INPUT_CANAL'
    INPUT_VS = 'INPUT_VS'
    INPUT_MASSA = 'INPUT_MASSA'

    def initAlgorithm(self, config):
        """
        Inicio do algoritmo onde iremos adicionar os parâmetros.
        """

        # Adicinando o input da drenagem como vector line.
        self.addParameter(
            QgsProcessingParameterFeatureSource(
                self.INPUT_DRENAGEM,
                self.tr('Drenagem'),
                [QgsProcessing.TypeVectorLine]
            )
        )

        # Adicionando o input do canal como vector line.
        self.addParameter(
            QgsProcessingParameterFeatureSource(
                self.INPUT_CANAL,
                self.tr('Canal'),
                [QgsProcessing.TypeVectorLine]
            )
        )

        # Adicionando o input do vertedouro e do sumidouro como um vector point.
        self.addParameter(
            QgsProcessingParameterFeatureSource(
                self.INPUT_VS,
                self.tr('Vertedouro e Sumidouro'),
                [QgsProcessing.TypeVectorPoint]
            )
        )

        # Adicionando o input das massas d'água como um vector polygon.
        self.addParameter(
            QgsProcessingParameterFeatureSource(
                self.INPUT_MASSA,
                self.tr("Massas d'Águas"),
                [QgsProcessing.TypeVectorPolygon]
            )
        )

        # Nossa saída dos FLAGS que irá poder receber a saída do tipo ponto.
        self.addParameter(
            QgsProcessingParameterFeatureSink(
                self.FLAGS,
                self.tr('{0} Flags').format(self.displayName())
            )
        )

        # Nossa saída dos FLAGS que irá poder receber a saída do tipo linha.
        self.addParameter(
            QgsProcessingParameterFeatureSink(
                self.FLAGS_LINHA,
                self.tr('{0} Flags_linha').format(self.displayName())
            )
        )

        # Nossa saída dos FLAGS que irá poder receber a saída do tipo polígono.
        self.addParameter(
            QgsProcessingParameterFeatureSink(
                self.FLAGS_POLIGONO,
                self.tr('{0} Flags_poligono').format(self.displayName())
            )
        )

    def processAlgorithm(self, parameters, context, feedback):
        """
        Processamento do algoritmo
        """

        # Declarando a variável que irá receber a entrada das drenagens.
        drenagem = self.parameterAsSource(parameters, self.INPUT_DRENAGEM, context)

        # Declarando a variável que irá receber a entrada do canal.
        canal = self.parameterAsSource(parameters, self.INPUT_CANAL, context)

        # Declarando a variável que irá receber a entrada do vertedouro e do sumidouro
        vs = self.parameterAsSource(parameters, self.INPUT_VS, context)

        # Declarando a variável que irá receber a entrada das massas d'água
        massaAgua = self.parameterAsSource(parameters, self.INPUT_MASSA, context)

        # Se a entrada na camada das drenagens for nula, será gerado um erro.
        if drenagem is None:
            raise QgsProcessingException(self.invalidSourceError(parameters, self.INPUT_DRENAGEM))
        
        # Criando o campo do atributo do flag de saída.
        fields = QgsFields()
        fields.append(QgsField("motivo_da_flag", QVariant.String))

        # Definindo os parâmetros de saída que poderá ser de qualquer tipo (ponto, linha ou polígono), armazenando
        # na variável sink.
        (sink, dest_id) = self.parameterAsSink(
            parameters, 
            self.FLAGS,
            context, 
            fields,
            QgsWkbTypes.Point,
            drenagem.sourceCrs()
        )

        (sink_linha, dest_id_linha) = self.parameterAsSink(
            parameters,
            self.FLAGS_LINHA,
            context,
            fields,
            QgsWkbTypes.LineString,
            drenagem.sourceCrs()
        )

        (sink_poligono, dest_id_poligono) = self.parameterAsSink(
            parameters,
            self.FLAGS_POLIGONO,
            context,
            fields,
            QgsWkbTypes.Polygon,
            drenagem.sourceCrs()
        )

        # Se o número de drenagens for nula, gerar um flag
        numDrenagem = drenagem.featureCount()
        if numDrenagem == 0:
            return {self.FLAGS: self.flag_id}

        # Compute the number of steps to display within the progress bar and
        # get features from source
        total = 100.0 / drenagem.featureCount() if drenagem.featureCount() else 0
        multiStepFeedback = QgsProcessingMultiStepFeedback(10, feedback)
        multiStepFeedback.setCurrentStep(0)
        multiStepFeedback.setProgressText(self.tr("Verificando estrtutura"))
        drenagens = drenagem.getFeatures()

        # Dicionário que indica quantas linhas entram e quantas linhas saem de dado ponto.
        dictEntramSaem = {}

        # Fazendo a iteração para adicionar ao dicionário criado o primeiro e o último ponto da iteração da drenagem
        # com o objetivo de verificar quantas linhas estão saindo e quantas estão entrando.
        for current, d in enumerate(drenagens):
            # Stop the algorithm if cancel button has been clicked
            if multiStepFeedback.isCanceled():
                break
            
            # Analisando os vértices correspondentes das drenagens e armazendo em uma lista, para analisar a 
            # quantidade de linhas que saem e que entram e assim poder inferir se alguma propriedade está 
            # sendo irregular.
            vertList = list(d.geometry().vertices())
            if len(vertList) == 0:
                continue
            primVert = vertList[0]
            ultiVert = vertList[-1]

            # Verificando se o primeiro ou ultimo vertice já está presente no dicionário:
            if primVert.asWkt() not in dictEntramSaem:
                dictEntramSaem[primVert.asWkt()] = {"chegando": 0, "saindo": 0}
            if ultiVert.asWkt() not in dictEntramSaem:
                dictEntramSaem[ultiVert.asWkt()] = {"chegando": 0, "saindo": 0}

            # Para os vértices que são os primeiros iremos adicionar uma linha saindo, para o caso do último vértice
            # vamos adicionar uma linha chegando.
            dictEntramSaem[primVert.asWkt()]["saindo"] += 1
            dictEntramSaem[ultiVert.asWkt()]["chegando"] += 1

            # Update the progress bar
            multiStepFeedback.setProgress(int(current * total))
        
        multiStepFeedback.setCurrentStep(1)
        
        # Iterando nos termos para analisar para cada pontos quantas linhas entram e quantas linhas
        # saem e com isso concluir se há algum erro na sua confecção.
        ################################  PROBLEMA 1 #############################################
        # For que irá retornar os pontos para o primeiro problema, erro de fluxo de drenagem.

        total = total / len(list(dictEntramSaem.keys()))

        for current, (ponto, qtdEntramSaem) in enumerate(dictEntramSaem.items()):
            if multiStepFeedback.isCanceled():
                break
            msgErro = self.erroQtdEntramSaem(qtdEntramSaem)
            if msgErro != '' and ((qtdEntramSaem["saindo"] != 1 and qtdEntramSaem["saindo"] != 0) or 
                                  (qtdEntramSaem["chegando"] != 1 and qtdEntramSaem["chegando"] != 0)):
                flagFeature = QgsFeature(fields)
                flagFeature.setGeometry(QgsGeometry.fromWkt(ponto))
                flagFeature["motivo_da_flag"] = msgErro
                # Adicionando na camada de saída a flag encontrada, temos:
                sink.addFeature(flagFeature, QgsFeatureSink.FastInsert)

            multiStepFeedback.setProgress(int(current * total))
        
        multiStepFeedback.setCurrentStep(2)

        ##################################### PROBLEMA 2 e 3 ######################################
        # Vamos analisar agora o fato do fluxo das drenagens terminar em um vertedouro ou começar em um
        # sumidouro.
        # Analisando se foi passado uma camada de vertedouro ou sumidouro
        if vs is None:
            pass
        else:
            
            total = total / vs.featureCount()

            for current, (ponto, qtdEntramSaem) in enumerate(dictEntramSaem.items()):
                # Caso o usuário deseje cancelar o processo
                if multiStepFeedback.isCanceled():
                    break
                featurePonto = QgsFeature()
                featurePonto.setGeometry(QgsGeometry.fromWkt(ponto))
                # Iterando na camada dos vertedouros e sumidouros:
                for current2, pontoVorS in enumerate(vs.getFeatures()):
                    # Analisando o caso do número de linhas saindo é 1 e o número de entrada é 0 e corresponde
                    # a um sumidouro
                    
                    # Verificando se o ponto de sumidouro ou vertedouro está dentro da feição do ponto da iteração
                    if featurePonto.geometry().within(pontoVorS.geometry()) == False:
                        continue
                    if (qtdEntramSaem["chegando"] == 0 and qtdEntramSaem["saindo"] == 1 and pontoVorS["tiposumvert"] == 1):
                        flagFeature = QgsFeature(fields)
                        flagFeature.setGeometry(QgsGeometry.fromWkt(pontoVorS.geometry().asWkt()))
                        flagFeature["motivo_da_flag"] = "Não pode ser um Sumidouro"
                        # Adicionando na camada de saída a flag encontrada, temos:
                        sink.addFeature(flagFeature, QgsFeatureSink.FastInsert)
                    # Analisando o caso do número de linhas saindo é 0 e o número de entrada é 1 e corresponde
                    # a um vertedouro
                    elif (qtdEntramSaem["chegando"] == 1 and qtdEntramSaem["saindo"] == 0 and pontoVorS["tiposumvert"] == 2):
                        flagFeature = QgsFeature(fields)
                        flagFeature.setGeometry(QgsGeometry.fromWkt(pontoVorS.geometry().asWkt()))
                        flagFeature["motivo_da_flag"] = "Não pode ser um Vertedouro"
                        # Adicionando na camada de saída a flag encontrada, temos:
                        sink.addFeature(flagFeature, QgsFeatureSink.FastInsert)
                    
                    multiStepFeedback.setProgress(int(current2 * total))
            
                multiStepFeedback.setCurrentStep(3)

                multiStepFeedback.setProgress(int(current * total))

            multiStepFeedback.setCurrentStep(4)
        
        ################################  PROBLEMA 4, 5 e 6 ##########################################
        # Vamos analisar as drenagens que se iniciam no ocenano/baía/enseada
        # Analisando os seguintes casos:
        # - massas d'água com fluxo sem drenagens internas
        # - massas d'água sem fluxo com drenagens internas
        if massaAgua is None:
            pass
        else: 
            # Criando um dicionário que será responsável pelo armazenamento das feições da massas d'água
            # que é dado por oceano/baía/enseada (sem fluxo) e seu respectivo indice espacial, fazendo o
            # mesmo para as massas d'água que possuem fluxo.
            dictMassasDaguaSemFluxo = {}
            massaDaguaSemFluxoSpatialIndex = QgsSpatialIndex()
            dictMassasDaguaComFluxo = {}
            massaDaguaComFluxoSpatialIndex = QgsSpatialIndex()

            # Criando uma lista que vai adicionar todas as feições das massas d'água com fluxo:
            listMassasComFluxo = []

            # Iterando para adicionar os que desejamos no dicionário e indice espacial correto:
            for massaDAgua in massaAgua.getFeatures():
                if massaDAgua["tipomassadagua"] in [3, 4, 5]:
                    dictMassasDaguaSemFluxo[massaDAgua.id()] = massaDAgua
                    massaDaguaSemFluxoSpatialIndex.addFeature(massaDAgua)
                else:
                    dictMassasDaguaComFluxo[massaDAgua.id()] = massaDAgua
                    massaDaguaComFluxoSpatialIndex.addFeature(massaDAgua)
                    listMassasComFluxo.append(massaDAgua.geometry())
            
            # Criando um dicionário para armazenar cada feição das massas d'água com fluxo e com um contador 
            # de quantos pontos estão em seu interior, além disso criando uma lista para adicionar os id's das feições
            # que foram adicionadas no dicionário, temos:
            dictFluxoCont = {}
            idFluxo = []

            total = total / len(dictEntramSaem.keys())

            # Agora iremos pegar do contexto espacial para analisar as drenagens que se intersectam 
            # com as massas d'água de oceano/baía/enseada (sem fluxo) para o problema 4
            for current, (ponto, qtdEntramSaem) in enumerate(dictEntramSaem.items()):
                # Se o usuário desejar cancelar o processo:
                if multiStepFeedback.isCanceled():
                    break
                # Criando a variável que é a feição do ponto:
                pontoFeature = QgsFeature()
                pontoFeature.setGeometry(QgsGeometry.fromWkt(ponto))
                # Geometria da feição do ponto:
                pontoGeom = pontoFeature.geometry()
                # Criando o bounding box a partir da geometria do ponto:
                bbox = pontoGeom.boundingBox()
                # Iterando sobre os indices espaciais das massa d'água que intersectam com as drenagens:
                for idMassaDagua in massaDaguaSemFluxoSpatialIndex.intersects(bbox):
                    # Acessando a feição a partir do dicionário:
                    featureMassaDagua = dictMassasDaguaSemFluxo[idMassaDagua]
                    geomMassaDagua = featureMassaDagua.geometry()
                    # Analisando se intersecta para analisar o problema 4, onde não podemos ter drenagens com fluxo
                    # saindo do oceano/baía/enseada:
                    if geomMassaDagua.intersects(pontoGeom):
                        if (qtdEntramSaem["chegando"] == 0 and qtdEntramSaem["saindo"] == 1):
                            flagFeature = QgsFeature(fields)
                            flagFeature.setGeometry(QgsGeometry.fromWkt(ponto))
                            flagFeature["motivo_da_flag"] = "Não se pode ter drenagem saindo de oceano/baía/enseada."
                            # Adicionando na camada de saída, temos:
                            sink.addFeature(flagFeature, QgsFeatureSink.FastInsert)

                # PROBLEMA 5
                # Iterando em cima dos pontos do dicionário, vamos analisar se o ponto faz intersecção com cada feição
                # das massas d'água com fluxo, e dentro um contador para cada feição, as que possuírem apenas 1 ou 0 
                # não possuem dentro de si drenagem.
                for idMassasComFluxo in massaDaguaComFluxoSpatialIndex.intersects(bbox):
                    # Adicionando a feição da massa em uma variável, temos:
                    featureMassaFluxo = dictMassasDaguaComFluxo[idMassasComFluxo]
                    geomMassaFluxo = featureMassaFluxo.geometry()
                    if geomMassaFluxo.asWkt() not in dictFluxoCont:
                        dictFluxoCont[geomMassaFluxo.asWkt()] = {"Pontos": 0}
                    dictFluxoCont[geomMassaFluxo.asWkt()]["Pontos"] += 1
                    idFluxo.append(idMassasComFluxo)
                
                multiStepFeedback.setProgress(int(current * total))

            multiStepFeedback.setCurrentStep(5)

            # Iterando sobre todos os índices das massas d'água e observando quais não estão na lista idFluxo
            # os que não estiverem, vamos adicionar à camada de saída.
            for i in list(dictMassasDaguaComFluxo.keys()):
                if i not in idFluxo:
                    flagFeature = QgsFeature(fields)
                    flagFeature.setGeometry(QgsGeometry.fromWkt(dictMassasDaguaComFluxo[i].geometry().asWkt()))
                    flagFeature["motivo_da_flag"] = "Não se pode ter massas d'água com fluxo sem drenagem interna."
                    # Adicionando na camada de saída, temos:
                    sink_poligono.addFeature(flagFeature, QgsFeatureSink.FastInsert)

            total = total / len((dictFluxoCont.keys()))

            # Iterando sobre o dicionário e verificando se há 1 ou 0 pontos no seu interior, temos:
            for current2, (chave, qtsPontos) in enumerate(dictFluxoCont.items()):
                if qtsPontos["Pontos"] == 1 or qtsPontos["Pontos"] == 0:
                    flagFeature = QgsFeature(fields)
                    flagFeature.setGeometry(QgsGeometry.fromWkt(chave))
                    flagFeature["motivo_da_flag"] = "Não se pode ter massas d'água com fluxo sem drenagem interna."
                    # Adicionando na camada de saída, temos:
                    sink_poligono.addFeature(flagFeature, QgsFeatureSink.FastInsert)

                multiStepFeedback.setProgress(int(current2 * total))
            
            multiStepFeedback.setCurrentStep(6)

            # Iterando nas drenagens de forma que iremos pegar as drenagens e analisar se as drenagens 
            # atravessam as massas d'água sem fluxo, ou não atravessam as massas d'água com fluxo.

            total = total / drenagem.featureCount()

            for current3, dFeat in enumerate(drenagem.getFeatures()):
                # Se o usuário desejar cancelar o processo:
                if multiStepFeedback.isCanceled():
                    break
                # Geometria da feição das drenagem que está sendo iterada, uma a uma.
                dGeom = dFeat.geometry()
                # Criando o bouding box a partir da geometria da feição da drenagem
                bboxDrenagem = dGeom.boundingBox()
                # Iterando sobre os índices espaciais das massas d'água sem fluxo que cruzam com as drenagens:
                for idMassaDagua in massaDaguaSemFluxoSpatialIndex.intersects(bboxDrenagem):
                    # Acessando a feição a partir do dicionário:
                    featureMassaDagua = dictMassasDaguaSemFluxo[idMassaDagua]
                    geomMassaDagua = featureMassaDagua.geometry()
                    # Analisando se cruza para analisar se drenagem cruza oceano/baía/enseada:
                    if dGeom.crosses(geomMassaDagua):
                        flagFeature = QgsFeature(fields)
                        flagFeature.setGeometry(QgsGeometry.fromWkt(dGeom.asWkt()))
                        flagFeature["motivo_da_flag"] = "Não se pode ter drenagem atravessando a massa d'água."
                        # Adicionando na camada de saída, temos:
                        sink_linha.addFeature(flagFeature, QgsFeatureSink.FastInsert)
                
                multiStepFeedback.setProgress(int(current3 * total))
            
            multiStepFeedback.setCurrentStep(7)
                

            



    def name(self):
        """
        Solução do Projeto 2
        """
        return 'Solução do Projeto 2'

    def displayName(self):
        """
        Retorna o nome do algoritmo traduzido.
        """
        return self.tr(self.name())

    def group(self):
        """
        Returns the name of the group this algorithm belongs to. This string
        should be localised.
        """
        return self.tr(self.groupId())

    def groupId(self):
        """
        Returns the unique ID of the group this algorithm belongs to. This
        string should be fixed for the algorithm, and must not be localised.
        The group id should be unique within each provider. Group id should
        contain lowercase alphanumeric characters only and no spaces or other
        formatting characters.
        """
        return 'Projeto 2'


    def tr(self, string):
        return QCoreApplication.translate('Projeto2Solucao', string)

    def createInstance(self):
        return Projeto2Solucao()
