# -*- coding: utf-8 -*-

"""
/***************************************************************************
 ProgramacaoAplicadaGrupo3
                                 A QGIS plugin
 Solução do Grupo 3
 Generated by Plugin Builder: http://g-sherman.github.io/Qgis-Plugin-Builder/
                              -------------------
        begin                : 2023-05-07
        copyright            : (C) 2023 by Grupo 3
        email                : matheus.silva@ime.eb.br
                               samuel.melo@ime.eb.br
                               reginaldo.filho@ime.eb.br
                               romeu.peris@ime.eb.br
 ***************************************************************************/

/***************************************************************************
 *                                                                         *
 *   This program is free software; you can redistribute it and/or modify  *
 *   it under the terms of the GNU General Public License as published by  *
 *   the Free Software Foundation; either version 2 of the License, or     *
 *   (at your option) any later version.                                   *
 *                                                                         *
 ***************************************************************************/
"""

__author__ = 'Grupo 3'
__date__ = '2023-03-20'
__copyright__ = '(C) 2023 by Grupo 3'

# This will get replaced with a git SHA1 when you do a git archive

__revision__ = '$Format:%H$'

from qgis.PyQt.QtCore import QCoreApplication, QVariant
from qgis.core import (QgsProcessing,
                       QgsFeatureSink,
                       QgsWkbTypes,
                       QgsProcessingMultiStepFeedback,
                       QgsField,
                       QgsSpatialIndex,
                       QgsFeature,
                       QgsProcessingException,
                       QgsProcessingAlgorithm,
                       QgsGeometry,
                       QgsFields,
                       QgsProcessingParameterFeatureSource,
                       QgsProcessingParameterFeatureSink)


class Projeto2Solucao(QgsProcessingAlgorithm):
    """
    Esse projeto tem por objetivo verificar as drenagens com sentido incorreto, drenagens que iniciam
    em sumidouro, drenagens que terminam em vertedouros, drenagens que iniciam no oceano, massas d'água
    com/sem fluxo sem/com drenagem interna, canal linha sem drenagem coincidentes e por fim vertedouros e 
    sumidouros devem estar relacionados com uma drenagem.
    """

    # Declarando os parâmetros que serão utilizados, como a flag que será retornado,
    # a drenagem, o canal, o vertedouro e sumidouro e por fim as massas d'água.

    FLAGS = 'FLAGS'
    FLAGS_LINHA = 'FLAGS_LINHA'
    FLAGS_POLIGONO = 'FLAGS_POLIGONO'
    INPUT_DRENAGEM = 'INPUT_DRENAGEM'
    INPUT_CANAL = 'INPUT_CANAL'
    INPUT_VS = 'INPUT_VS'
    INPUT_MASSA = 'INPUT_MASSA'

    def initAlgorithm(self, config):
        """
        Inicio do algoritmo onde iremos adicionar os parâmetros.
        """

        # Adicinando o input da drenagem como vector line.
        self.addParameter(
            QgsProcessingParameterFeatureSource(
                self.INPUT_DRENAGEM,
                self.tr('Drenagem'),
                [QgsProcessing.TypeVectorLine]
            )
        )

        # Adicionando o input do canal como vector line.
        self.addParameter(
            QgsProcessingParameterFeatureSource(
                self.INPUT_CANAL,
                self.tr('Canal'),
                [QgsProcessing.TypeVectorLine]
            )
        )

        # Adicionando o input do vertedouro e do sumidouro como um vector point.
        self.addParameter(
            QgsProcessingParameterFeatureSource(
                self.INPUT_VS,
                self.tr('Vertedouro e Sumidouro'),
                [QgsProcessing.TypeVectorPoint]
            )
        )

        # Adicionando o input das massas d'água como um vector polygon.
        self.addParameter(
            QgsProcessingParameterFeatureSource(
                self.INPUT_MASSA,
                self.tr("Massas d'Águas"),
                [QgsProcessing.TypeVectorPolygon]
            )
        )

        # Nossa saída dos FLAGS que irá poder receber a saída do tipo ponto.
        self.addParameter(
            QgsProcessingParameterFeatureSink(
                self.FLAGS,
                self.tr('{0} Flags').format(self.displayName())
            )
        )

        # Nossa saída dos FLAGS que irá poder receber a saída do tipo linha.
        self.addParameter(
            QgsProcessingParameterFeatureSink(
                self.FLAGS_LINHA,
                self.tr('{0} Flags_linha').format(self.displayName())
            )
        )

        # Nossa saída dos FLAGS que irá poder receber a saída do tipo polígono.
        self.addParameter(
            QgsProcessingParameterFeatureSink(
                self.FLAGS_POLIGONO,
                self.tr('{0} Flags_poligono').format(self.displayName())
            )
        )

    def processAlgorithm(self, parameters, context, feedback):
        """
        Processamento do algoritmo
        """

        # Declarando a variável que irá receber a entrada das drenagens.
        drenagem = self.parameterAsSource(parameters, self.INPUT_DRENAGEM, context)

        # Declarando a variável que irá receber a entrada do canal.
        canal = self.parameterAsSource(parameters, self.INPUT_CANAL, context)

        # Declarando a variável que irá receber a entrada do vertedouro e do sumidouro
        vs = self.parameterAsSource(parameters, self.INPUT_VS, context)

        # Declarando a variável que irá receber a entrada das massas d'água
        massaAgua = self.parameterAsSource(parameters, self.INPUT_MASSA, context)

        # Se a entrada na camada das drenagens for nula, será gerado um erro.
        if drenagem is None:
            raise QgsProcessingException(self.invalidSourceError(parameters, self.INPUT_DRENAGEM))
        
        # Criando o campo do atributo do flag de saída.
        fields = QgsFields()
        fields.append(QgsField("motivo_da_flag", QVariant.String))

        # Definindo os parâmetros de saída que poderá ser de qualquer tipo (ponto, linha ou polígono), armazenando
        # na variável sink.
        (sink, dest_id) = self.parameterAsSink(
            parameters, 
            self.FLAGS,
            context, 
            fields,
            QgsWkbTypes.Point,
            drenagem.sourceCrs()
        )

        (sink_linha, dest_id_linha) = self.parameterAsSink(
            parameters,
            self.FLAGS_LINHA,
            context,
            fields,
            QgsWkbTypes.LineString,
            drenagem.sourceCrs()
        )

        (sink_poligono, dest_id_poligono) = self.parameterAsSink(
            parameters,
            self.FLAGS_POLIGONO,
            context,
            fields,
            QgsWkbTypes.Polygon,
            drenagem.sourceCrs()
        )

        # Se o número de drenagens for nula, gerar um flag
        numDrenagem = drenagem.featureCount()
        if numDrenagem == 0:
            return {self.FLAGS: self.flag_id}

        # Compute the number of steps to display within the progress bar and
        # get features from source
        total = 100.0 / drenagem.featureCount() if drenagem.featureCount() else 0
        multiStepFeedback = QgsProcessingMultiStepFeedback(10, feedback)
        multiStepFeedback.setCurrentStep(0)
        multiStepFeedback.setProgressText(self.tr("Verificando estrtutura"))
        drenagens = drenagem.getFeatures()

        # Dicionário que indica quantas linhas entram e quantas linhas saem de dado ponto.
        dictEntramSaem = {}

        # Fazendo a iteração para adicionar ao dicionário criado o primeiro e o último ponto da iteração da drenagem
        # com o objetivo de verificar quantas linhas estão saindo e quantas estão entrando.
        for current, d in enumerate(drenagens):
            # Stop the algorithm if cancel button has been clicked
            if multiStepFeedback.isCanceled():
                break
            
            # Analisando os vértices correspondentes das drenagens e armazendo em uma lista, para analisar a 
            # quantidade de linhas que saem e que entram e assim poder inferir se alguma propriedade está 
            # sendo irregular.
            vertList = list(d.geometry().vertices())
            if len(vertList) == 0:
                continue
            primVert = vertList[0]
            ultiVert = vertList[-1]

            # Verificando se o primeiro ou ultimo vertice já está presente no dicionário:
            if primVert.asWkt() not in dictEntramSaem:
                dictEntramSaem[primVert.asWkt()] = {"chegando": 0, "saindo": 0}
            if ultiVert.asWkt() not in dictEntramSaem:
                dictEntramSaem[ultiVert.asWkt()] = {"chegando": 0, "saindo": 0}

            # Para os vértices que são os primeiros iremos adicionar uma linha saindo, para o caso do último vértice
            # vamos adicionar uma linha chegando.
            dictEntramSaem[primVert.asWkt()]["saindo"] += 1
            dictEntramSaem[ultiVert.asWkt()]["chegando"] += 1

            # Update the progress bar
            multiStepFeedback.setProgress(int(current * total))
        
        multiStepFeedback.setCurrentStep(1)
        
        # Iterando nos termos para analisar para cada pontos quantas linhas entram e quantas linhas
        # saem e com isso concluir se há algum erro na sua confecção.
        ################################  PROBLEMA 1 #############################################
        # For que irá retornar os pontos para o primeiro problema, erro de fluxo de drenagem.

        total = total / len(list(dictEntramSaem.keys()))

        for current, (ponto, qtdEntramSaem) in enumerate(dictEntramSaem.items()):
            if multiStepFeedback.isCanceled():
                break
            msgErro = self.erroQtdEntramSaem(qtdEntramSaem)
            if msgErro != '' and ((qtdEntramSaem["saindo"] != 1 and qtdEntramSaem["saindo"] != 0) or 
                                  (qtdEntramSaem["chegando"] != 1 and qtdEntramSaem["chegando"] != 0)):
                flagFeature = QgsFeature(fields)
                flagFeature.setGeometry(QgsGeometry.fromWkt(ponto))
                flagFeature["motivo_da_flag"] = msgErro
                # Adicionando na camada de saída a flag encontrada, temos:
                sink.addFeature(flagFeature, QgsFeatureSink.FastInsert)

            multiStepFeedback.setProgress(int(current * total))
        
        multiStepFeedback.setCurrentStep(2)

        ##################################### PROBLEMA 2 e 3 ######################################
        # Vamos analisar agora o fato do fluxo das drenagens terminar em um vertedouro ou começar em um
        # sumidouro.
        # Analisando se foi passado uma camada de vertedouro ou sumidouro
        if vs is None:
            pass
        else:
            
            total = total / vs.featureCount()

            for current, (ponto, qtdEntramSaem) in enumerate(dictEntramSaem.items()):
                # Caso o usuário deseje cancelar o processo
                if multiStepFeedback.isCanceled():
                    break
                featurePonto = QgsFeature()
                featurePonto.setGeometry(QgsGeometry.fromWkt(ponto))
                # Iterando na camada dos vertedouros e sumidouros:
                for current2, pontoVorS in enumerate(vs.getFeatures()):
                    # Analisando o caso do número de linhas saindo é 1 e o número de entrada é 0 e corresponde
                    # a um sumidouro
                    
                    # Verificando se o ponto de sumidouro ou vertedouro está dentro da feição do ponto da iteração
                    if featurePonto.geometry().within(pontoVorS.geometry()) == False:
                        continue
                    if (qtdEntramSaem["chegando"] == 0 and qtdEntramSaem["saindo"] == 1 and pontoVorS["tiposumvert"] == 1):
                        flagFeature = QgsFeature(fields)
                        flagFeature.setGeometry(QgsGeometry.fromWkt(pontoVorS.geometry().asWkt()))
                        flagFeature["motivo_da_flag"] = "Não pode ser um Sumidouro"
                        # Adicionando na camada de saída a flag encontrada, temos:
                        sink.addFeature(flagFeature, QgsFeatureSink.FastInsert)
                    # Analisando o caso do número de linhas saindo é 0 e o número de entrada é 1 e corresponde
                    # a um vertedouro
                    elif (qtdEntramSaem["chegando"] == 1 and qtdEntramSaem["saindo"] == 0 and pontoVorS["tiposumvert"] == 2):
                        flagFeature = QgsFeature(fields)
                        flagFeature.setGeometry(QgsGeometry.fromWkt(pontoVorS.geometry().asWkt()))
                        flagFeature["motivo_da_flag"] = "Não pode ser um Vertedouro"
                        # Adicionando na camada de saída a flag encontrada, temos:
                        sink.addFeature(flagFeature, QgsFeatureSink.FastInsert)
                    
                    multiStepFeedback.setProgress(int(current2 * total))
            
                multiStepFeedback.setCurrentStep(3)

                multiStepFeedback.setProgress(int(current * total))

            multiStepFeedback.setCurrentStep(4)


    def name(self):
        """
        Solução do Projeto 2
        """
        return 'Solução do Projeto 2'

    def displayName(self):
        """
        Retorna o nome do algoritmo traduzido.
        """
        return self.tr(self.name())

    def group(self):
        """
        Returns the name of the group this algorithm belongs to. This string
        should be localised.
        """
        return self.tr(self.groupId())

    def groupId(self):
        """
        Returns the unique ID of the group this algorithm belongs to. This
        string should be fixed for the algorithm, and must not be localised.
        The group id should be unique within each provider. Group id should
        contain lowercase alphanumeric characters only and no spaces or other
        formatting characters.
        """
        return 'Projeto 2'


    def tr(self, string):
        return QCoreApplication.translate('Projeto2Solucao', string)

    def createInstance(self):
        return Projeto2Solucao()
