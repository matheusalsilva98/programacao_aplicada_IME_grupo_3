# -*- coding: utf-8 -*-

"""
/***************************************************************************
 ProgramacaoAplicadaGrupo3
                                 A QGIS plugin
 Solução do Grupo 3
 Generated by Plugin Builder: http://g-sherman.github.io/Qgis-Plugin-Builder/
                              -------------------
        begin                : 2023-03-20
        copyright            : (C) 2023 by Grupo 3
        email                : matheus.silva@ime.eb.br
                               samuel.melo@ime.eb.br
                               reginaldo.filho@ime.eb.br
                               romeu.peris@ime.eb.br
 ***************************************************************************/

/***************************************************************************
 *                                                                         *
 *   This program is free software; you can redistribute it and/or modify  *
 *   it under the terms of the GNU General Public License as published by  *
 *   the Free Software Foundation; either version 2 of the License, or     *
 *   (at your option) any later version.                                   *
 *                                                                         *
 ***************************************************************************/
"""

__author__ = 'Grupo 3'
__date__ = '2023-03-20'
__copyright__ = '(C) 2023 by Grupo 3'

# This will get replaced with a git SHA1 when you do a git archive

__revision__ = '$Format:%H$'

from qgis.PyQt.QtCore import QCoreApplication, QVariant
from qgis.core import (QgsProcessing,
                       QgsFeatureSink,
                       QgsProcessingParameterRasterLayer,
                       QgsProcessingAlgorithm,
                       QgsWkbTypes,
                       QgsFeature,
                       QgsProcessingParameterMultipleLayers,
                       QgsGeometry,
                       QgsFields,
                       QgsVectorLayer,
                       QgsPointXY,
                       QgsField,
                       QgsProcessingException,
                       QgsProcessingParameterFeatureSource,
                       QgsProcessingParameterFeatureSink)
import numpy as np

class Projeto1SolucaoComplementar(QgsProcessingAlgorithm):
    """
    This is an example algorithm that takes a vector layer and
    creates a new identical one.

    It is meant to be used as an example of how to create your own
    algorithms and explain methods and variables used to do it. An
    algorithm like this will be available in all elements, and there
    is not need for additional work.

    All Processing algorithms should extend the QgsProcessingAlgorithm
    class.
    """

    # Declarando os nossos parâmetros que utilizaremos para a resolução da questão.

    OUTPUT = 'OUTPUT'
    INPUT = 'INPUT'

    def initAlgorithm(self, config):
        """
        Definindo os parâmetros de entrada (INPUT).
        """

        # Adicionando o parâmetro para processar multiplas camadas como entrada (INPUT).

        self.addParameter(
            QgsProcessingParameterMultipleLayers(
                self.INPUT,
                self.tr('Input layer'),
                layerType = QgsProcessing.TypeRaster
            )
        )

        # Adicionando o parâmetro de saída (OUTPUT).

        self.addParameter(
            QgsProcessingParameterFeatureSink(
                self.OUTPUT,
                self.tr('Output layer')
            )
        )

    def processAlgorithm(self, parameters, context, feedback):
        """
        Teremos o efetivo desenvolvimento do algoritmo nessa etapa, resultando no
        nosso produto final.
        """

        # Criando a variável raster para receber uma lista de rasters de entrada (INPUT).
        listaRaster = self.parameterAsLayerList(parameters, self.INPUT, context)

        # Criando os atributos necessários da camada de saída chamando de fields, temos:

        fields = QgsFields()
        fields.append(QgsField("raster1", QVariant.String))
        fields.append(QgsField("raster2", QVariant.String))
        fields.append(QgsField("erro", QVariant.Double))

        # Criando a variável que irá receber os resultados obtidos a partir da comparação entre as camadas Raster.
        (sink, dest_id) = self.parameterAsSink(parameters, self.OUTPUT,
                context, fields, QgsWkbTypes.Polygon, listaRaster[0].crs())
        

        # É criada a variável total para se avaliar o progresso do algoritmo.
        total = 100.0 / len(listaRaster) if len(listaRaster) else 0

        for current, i in enumerate(range(len(listaRaster))):
            # Caso o usuário deseje cancelar o processo, poderá.
            if feedback.isCanceled():
                break
            
            for current2, j in enumerate(range(len(listaRaster))):
                
                if i != j:
                    
                    # Armazenando em variáveis os quadriláteros que envolvem as imagens da iteração.
                    quadRasterI = listaRaster[i].extent()
                    quadRasterJ = listaRaster[j].extent()

                    # Criando 4 variáveis para cada quadrilátero que irá representar os vértices, teremos:
                    pontoI1 = f"{quadRasterI.xMinimum()} {quadRasterI.yMinimum()}"
                    pontoI2 = f"{quadRasterI.xMinimum()} {quadRasterI.yMaximum()}"
                    pontoI3 = f"{quadRasterI.xMaximum()} {quadRasterI.yMaximum()}"
                    pontoI4 = f"{quadRasterI.xMaximum()} {quadRasterI.yMinimum()}"

                    pontoJ1 = f"{quadRasterJ.xMinimum()} {quadRasterJ.yMinimum()}"
                    pontoJ2 = f"{quadRasterJ.xMinimum()} {quadRasterJ.yMaximum()}"
                    pontoJ3 = f"{quadRasterJ.xMaximum()} {quadRasterJ.yMaximum()}"
                    pontoJ4 = f"{quadRasterJ.xMaximum()} {quadRasterJ.yMinimum()}"

                    # Criando as variáveis quadFeatureI e quadFeatureJ para reservar as features 
                    # criadas com os vértices.
                    quadFeatureI = QgsFeature()
                    quadFeatureJ = QgsFeature()

                    # Ajeitando a geometria com o setGeometry() para conseguir adicionar os vértices.
                    quadFeatureI.setGeometry(QgsGeometry.fromWkt(f"POLYGON (({pontoI1}, {pontoI2}, {pontoI3}, {pontoI4}, {pontoI1}))"))
                    quadFeatureJ.setGeometry(QgsGeometry.fromWkt(f"POLYGON (({pontoJ1}, {pontoJ2}, {pontoJ3}, {pontoJ4}, {pontoJ1}))"))