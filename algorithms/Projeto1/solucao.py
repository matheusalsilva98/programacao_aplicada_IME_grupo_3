# -*- coding: utf-8 -*-

"""
/***************************************************************************
 ProgramacaoAplicadaGrupo3
                                 A QGIS plugin
 Solução do Grupo 3
 Generated by Plugin Builder: http://g-sherman.github.io/Qgis-Plugin-Builder/
                              -------------------
        begin                : 2023-03-20
        copyright            : (C) 2023 by Grupo 3
        email                : matheus.silva@ime.eb.br
                               samuel.melo@ime.eb.br
                               reginaldo.filho@ime.eb.br
                               romeu.peris@ime.eb.br
 ***************************************************************************/

/***************************************************************************
 *                                                                         *
 *   This program is free software; you can redistribute it and/or modify  *
 *   it under the terms of the GNU General Public License as published by  *
 *   the Free Software Foundation; either version 2 of the License, or     *
 *   (at your option) any later version.                                   *
 *                                                                         *
 ***************************************************************************/
"""

__author__ = 'Grupo 3'
__date__ = '2023-03-20'
__copyright__ = '(C) 2023 by Grupo 3'

# This will get replaced with a git SHA1 when you do a git archive

__revision__ = '$Format:%H$'
from qgis.PyQt.QtCore import QCoreApplication, QVariant
from qgis.core import (QgsProcessing,
                       QgsWkbTypes,
                       QgsFields,
                       QgsField,
                       QgsFeature,
                       QgsProcessingParameterRasterLayer,
                       QgsGeometry,
                       QgsPointXY,
                       QgsFeatureSink,
                       QgsProcessingAlgorithm,
                       QgsProcessingParameterFeatureSource,
                       QgsProcessingParameterFeatureSink)


class Projeto1Solucao(QgsProcessingAlgorithm):
    """
    This is an example algorithm that takes a vector layer and
    creates a new identical one.

    It is meant to be used as an example of how to create your own
    algorithms and explain methods and variables used to do it. An
    algorithm like this will be available in all elements, and there
    is not need for additional work.

    All Processing algorithms should extend the QgsProcessingAlgorithm
    class.
    """

    # Declarando os nossos parâmetros que utilizaremos para a resolução da questão.

    OUTPUT = 'OUTPUT'
    PONTOS_CONTROLE = 'PONTOS_CONTROLE'
    INPUT = 'INPUT'

    def initAlgorithm(self, config):
        """
        Here we define the inputs and output of the algorithm, along
        with some other properties.
        """

        # Adicionando o parâmetro de entrada como sendo do tipo Raster (INPUT).
        self.addParameter(
            QgsProcessingParameterRasterLayer(
                self.INPUT,
                self.tr('Input layer'),
                [QgsProcessing.TypeRaster]
            )
        )
        
        # Adicionando o parâmetro que receberá os pontos de controle para comparativo com os pontos da imagem.
        self.addParameter(
            QgsProcessingParameterFeatureSource(
            self.PONTOS_CONTROLE,
            self.tr('Pontos de controle'),
            [QgsProcessing.TypeVectorPoint]
            )
        )

        # Adicionando o parâmetro de saída (OUTPUT)
        self.addParameter(
            QgsProcessingParameterFeatureSink(
                self.OUTPUT,
                self.tr('Output layer')
            )
        )

    def processAlgorithm(self, parameters, context, feedback):
        """
        Here is where the processing itself takes place.
        """

        # Declarando a variável raster que receberá a entrada.
        raster = self.parameterAsRasterLayer(parameters, self.INPUT, context)

        # Declarando a variável pontos_controle que recebrá a camada dos pontos de controle.
        pontos_controle = self.parameterAsSource(parameters, self.PONTOS_CONTROLE, context)

        # Criando o atributo flag para as features de saída, do tipo númerico double (decimal).
        fields = QgsFields()
        fields.append(QgsField("erro", QVariant.Double))

        # Declarando a variável e o id que receberão a camada de saída.
        (sink, dest_id) = self.parameterAsSink(parameters, self.OUTPUT,
                context, fields, QgsWkbTypes.Polygon, raster.crs())
        
        # Criando a variável retanguloRaster para receber o método extent na camada raster inserida como input.
        retanguloRaster = raster.extent()

        # Criando 4 variáveis, as quais vão receber os vértices adquiridos a partir do extent do raster.
        ponto1 = f'{retanguloRaster.xMinimum()} {retanguloRaster.yMinimum()}'
        ponto2 = f'{retanguloRaster.xMinimum()} {retanguloRaster.yMaximum()}'
        ponto3 = f'{retanguloRaster.xMaximum()} {retanguloRaster.yMaximum()}'
        ponto4 = f'{retanguloRaster.xMaximum()} {retanguloRaster.yMinimum()}'
        
        # Criando a variável retanguloFeatureRaster para receber a feature com as limitações do raster de entrada, que foram
        # obtido a partir da variável retanguloRaster.
        retanguloFeatureRaster = QgsFeature()
        # Incrementando as coordendas do boundingBox que se consegue a partir da variável retanguloRaster, podemos colocar geometria 
        # na nossa feature criada.
        retanguloFeatureRaster.setGeometry(QgsGeometry.fromWkt(f"POLYGON (({ponto1}, {ponto2}, {ponto3}, {ponto4}, {ponto1}))"))
        

        # Criando a variável total que medirá o progresso.
        total = 100.0 / pontos_controle.featureCount() if pontos_controle.featureCount() else 0
        # Pegando todos os pontos presentes na camada pontos de controle inserida a partir do csv.
        features = pontos_controle.getFeatures()

        # Criando uma variável que tem por finalidade armazenar os valores dos erros,  erros = z_t - z_r.
        lista_erros = []
