# -*- coding: utf-8 -*-

"""
/***************************************************************************
 ProgramacaoAplicadaGrupo3
                                 A QGIS plugin
 Solução do Grupo 3
 Generated by Plugin Builder: http://g-sherman.github.io/Qgis-Plugin-Builder/
                              -------------------
        begin                : 2023-05-07
        copyright            : (C) 2023 by Grupo 3
        email                : matheus.silva@ime.eb.br
                               samuel.melo@ime.eb.br
                               reginaldo.filho@ime.eb.br
                               romeu.peris@ime.eb.br
 ***************************************************************************/

/***************************************************************************
 *                                                                         *
 *   This program is free software; you can redistribute it and/or modify  *
 *   it under the terms of the GNU General Public License as published by  *
 *   the Free Software Foundation; either version 2 of the License, or     *
 *   (at your option) any later version.                                   *
 *                                                                         *
 ***************************************************************************/
"""

__author__ = 'Grupo 3'
__date__ = '2023-03-20'
__copyright__ = '(C) 2023 by Grupo 3'

# This will get replaced with a git SHA1 when you do a git archive

__revision__ = '$Format:%H$'

from qgis.PyQt.QtCore import QCoreApplication, QVariant
from qgis.core import (QgsProcessing,
                       QgsFeatureSink,
                       QgsWkbTypes,
                       QgsPointXY,
                       QgsProcessingMultiStepFeedback,
                       QgsField,
                       QgsProcessingParameterNumber,
                       QgsSpatialIndex,
                       QgsProcessingUtils,
                       QgsFeature,
                       QgsProcessingException,
                       QgsProcessingAlgorithm,
                       QgsGeometry,
                       QgsFields,
                       QgsProcessingParameterFeatureSource,
                       QgsProcessingParameterFeatureSink)


class Projeto3Solucao(QgsProcessingAlgorithm):
    """
    Esse algoritmo tem por finalidade solucionar o projeto 3, referente a uma melhor visualização
    espacial das camadas de entrada, que foram a rodovia e os edifícios.
    """

    # Declarando as variáveis que serão utilizadas.
    OUTPUT = 'OUTPUT'
    INPUT_RODOVIAS = 'INPUT_RODOVIAS'
    DISTANCIA_DESLOCAMENTO = 'DISTANCIA_DESLOCAMENTO'
    INPUT_EDIFICIOS = 'INPUT_EDIFICIOS'

    def initAlgorithm(self, config):
        """
        Aqui será iniciado o algoritmo, onde serão adicionado os parâmetros declarados anteriormente.
        """

        # Adicionando inicialmente o parâmetro das rodovias
        self.addParameter(
            QgsProcessingParameterFeatureSource(
                self.INPUT_RODOVIAS,
                self.tr('Camada das rodovias'),
                [QgsProcessing.TypeVectorLine]
            )
        )

        # Adicionando o parâmetro dos edifícios
        self.addParameter(
            QgsProcessingParameterFeatureSource(
                self.INPUT_EDIFICIOS,
                self.tr('Camada dos edícios'),
                [QgsProcessing.TypeVectorPoint]
            )
        )

        # Adicionando o parâmetro da distância máxima
        self.addParameter(
            QgsProcessingParameterNumber(
                self.DISTANCIA_DESLOCAMENTO,
                self.tr('Distância de deslocamento'),
                type=QgsProcessingParameterNumber.Double

            )
        )

        # Adicionando o parâmetro da camada de saída
        self.addParameter(
            QgsProcessingParameterFeatureSink(
                self.OUTPUT,
                self.tr('Output layer')
            )
        )

    def processAlgorithm(self, parameters, context, feedback):
        """
        Aqui será feita o processamento do algoritmo.
        """

        # Alocando na variável edificios a camada de entrada dos edifícios, temos:
        edificios = self.parameterAsSource(
            parameters, self.INPUT_EDIFICIOS, context)

        # Alocando na variável rodovia a camada de entrada da rodovia, temos:
        rodovia = self.parameterAsSource(
            parameters, self.INPUT_RODOVIAS, context)

        # Alocando na variável dist_deslocamento o número passado como valor no processing:
        dist_deslocamento = self.parameterAsDouble(
            parameters, self.DISTANCIA_DESLOCAMENTO, context)

        # Alocando a camada de saída na variável sink
        (sink, dest_id) = self.parameterAsSink(parameters, self.OUTPUT,
                                               context, edificios.fields(), QgsWkbTypes.Point, rodovia.sourceCrs())

        # Adicionando o multistepfeedback para poder mostrar na tela o carregamento
        multiStepFeedback = QgsProcessingMultiStepFeedback(10, feedback)
        multiStepFeedback.setCurrentStep(0)
        multiStepFeedback.setProgressText(self.tr("Verificando estrtutura"))

        # Criando um dicionário que vai armazenar como chave a feature das rodovias e dos edifícios, temos:
        dictRodovias = {}
        dictEdificios = {}
        # Criando a variável que vai armazenar o índice espacial tanto da rodovia quanto dos edifícios, temos:
        rodoIndiceEspacial = QgsSpatialIndex()
        edifIndiceEspacial = QgsSpatialIndex()

        # Iterando para armazenar no dicionário e no indice espacial:
        for rodo in rodovia.getFeatures():
            dictRodovias[rodo.id()] = rodo
            rodoIndiceEspacial.addFeature(rodo)

        for edif in edificios.getFeatures():
            dictEdificios[edif.id()] = edif
            edifIndiceEspacial.addFeature(edif)

        # Criando um dicionário para associar o indice da feature da rodovia com o buffer que será aplicado
        # nessa parte da rodovia, tanto na direita quanto na esquerda:
        dictBufferEsquerda = {}
        dictBufferDireita = {}

        # Essa iteração inicial é apenas para armazenar o índice da feature analisada como chave do dicionário e
        # a feature com o buffer no valor do dicionário.
        for current, feature in enumerate(rodovia.getFeatures()):
            # Parar o processing caso o usuário deseje.
            if feedback.isCanceled():
                break

            # Criando a feature que irá receber o buffer da direita e armazenando essa feição com o índice da feature
            # correspondente inicialmente.
            # Foi aplicado um buffer tanto unilateral quanto um buffer pra pegar toda a limitação da rodovia, cobrindo
            # assim toda a extensão da via e a parte unilateral específicada.
            featBufferDir = QgsFeature()
            featBufferDir.setGeometry(feature.geometry().singleSidedBuffer(
                (12.5 + 12.5 * (2) ** (1/2)), -1, QgsGeometry.SideRight).buffer(10, -1))
            #sink.addFeature(featBufferDir, QgsFeatureSink.FastInsert)

            # Armazenando no dicionário criado para o buffer da direita:
            dictBufferDireita[feature.id()] = featBufferDir

            # Criando a feature que irá receber o buffer da esquerda e armazenando essa feição com o índice da
            # feature correspondente inicialmente.
            # Foi aplicado um buffer tanto unilateral quanto um buffer pra pegar toda a limitação da rodovia, cobrindo
            # assim toda a extensão da via e a parte unilateral específicada.
            featBufferEsq = QgsFeature()
            featBufferEsq.setGeometry(feature.geometry().singleSidedBuffer(
                (12.5 + 12.5 * (2) ** (1/2)), -1, QgsGeometry.SideLeft).buffer(10, -1))
            #sink.addFeature(featBufferEsq, QgsFeatureSink.FastInsert)

            # Armazenando no dicionário criado para o buffer da esquerda:
            dictBufferEsquerda[feature.id()] = featBufferEsq

        # Multistepfeedback
        multiStepFeedback.setCurrentStep(1)

        # Criando o dicionário que irá armazenar os edifícios com o buffer da circunferência, com o mesmo id da feição normal
        dictEdiBuffer = {}

        for current2, edi in enumerate(edificios.getFeatures()):
            # Parar o processing caso o usuário deseje.
            if feedback.isCanceled():
                break

            # Criando a feição que irá receber o buffer e será armazenada no dicionário
            featEdiBuffer = QgsFeature()
            featEdiBuffer.setGeometry(
                edi.geometry().buffer(12.5 * (2) ** (1/2), 200))

            # Armazenando no dicionário criado para o buffer da circunferência circunscrita no ponto:
            dictEdiBuffer[edi.id()] = featEdiBuffer

        # Multistepfeedback
        multiStepFeedback.setCurrentStep(2)

        # Criando dicionários para armazenar quais edifícios estão dentro do buffer da direita, quais edifícios estão
        # dentro do buffer da esquerda, quais edifícios intersectam o da direita e quais edifícios intersectam o da esquerda,
        # um dicionário para armazenar quanto o ponto foi deslocado pelo seu índice, para que não extrapole a distância e por fim
        # um dicionário para armazenar a distância entre a rodovia e o edifício para verificar qual a menor, totalizando 6 dicionários:
        dictEdiDentroBufDir = {}
        dictEdiDentroBufEsq = {}
        dictEdiIntBufDir = {}
        dictEdiIntBufEsq = {}
        dictEdiDistancia = {}
        dictDistEdiRodoDir = {}
        dictDistEdiRodoEsq = {}

        # Como forma de analisar as bifurcações que ocorre em algumas partes da rodovia e nesse espaço entre as vias possui
        # edifícios, iremos agora encontrar esses pontos, onde isso ocorre para posteriormente aplicar um buffer e analisar
        # quais edifícios se encontram na sua região:
        dictBifurcacao = {}

        # Criando a lista dos edifícios que foram deslocados, para que não se tenha mais de um deslocamento com o mesmo
        # edifício, onde a chave será o índice do edifício e como valor será a feature buffada, por enquanto.
        dictEdificiosDeslocados = {}

        for current6, feaRodo in enumerate(rodovia.getFeatures()):
            # Pegando os vértices dessa feição e armazenando em uma lista:
            listVert = list(feaRodo.geometry().vertices())
            primVert = listVert[0]
            ultVert = listVert[-1]

            # Analisando se o vértice já se encontra no dicionário:
            if primVert.asWkt() not in dictBifurcacao:
                dictBifurcacao[primVert.asWkt()] = {"chegando": 0, "saindo": 0}
            if ultVert.asWkt() not in dictBifurcacao:
                dictBifurcacao[ultVert.asWkt()] = {"chegando": 0, "saindo": 0}

            # E logo após passar o if, iremos adicionar um saindo para o primeiro vértice e
            # um chegando para o ultimo vértice
            dictBifurcacao[primVert.asWkt()]["saindo"] += 1
            dictBifurcacao[ultVert.asWkt()]["chegando"] += 1

        # Multistepfeedback
        multiStepFeedback.setCurrentStep(3)

        # Verificando dos pontos qual possui soma maior que 2 de chegando e saindo, pois esses serão pontos de
        # bifurcação:
        # Armazenando os pontos que possuem essa característica na lista abaixo:
        listaBifurca = []
        # Adicionando os pontos que são ponta, para verificar se aplicado um buffer nesse ponto intersecta com algum
        # edifício, temos:
        listaPonta = []

        for items in dictBifurcacao.items():
            chegando = items[1]["chegando"]
            saindo = items[1]["saindo"]

            total = chegando + saindo

            if total > 2:
                listaBifurca.append(items[0])
            elif total == 1:
                listaPonta.append(items[0])

        for i in listaBifurca:
            feature = QgsFeature()
            feature.setGeometry(QgsGeometry.fromWkt(i).buffer(12.5, 200))
            #sink.addFeature(feature, QgsFeatureSink.FastInsert)

        # Criando a lista para adicionar o índice dos edifício que fazem intersecção tanto com os dois
        # lados da rodovia, temos:
        edificiosInt = []

        # Iterando então sobre as features da camada de rodovias e analisando pelo indice espacial quais edifícios intersectam
        # para a sua analise se o edíficio está contido ou não nesse buffer.
        for current3, featureRod in enumerate(rodovia.getFeatures()):
            # Para o processo caso o usuário deseje.
            if feedback.isCanceled():
                break

            # Encontrando no dicionário de cada buffer da camada da rodovia pelo seu id, temos:
            # Para o buffer no lado da direita
            featRodBufDir = dictBufferDireita[featureRod.id()]

            # Para o buffer no lado da esquerda
            featRodBufEsq = dictBufferEsquerda[featureRod.id()]

            # Criando a variável para armazenar a geometria para cada lado de buffer:
            geomRodBufDir = featRodBufDir.geometry()
            geomRodBufEsq = featRodBufEsq.geometry()

            # Criando a variável para armazenar o bounding box da geometria de cada camada:
            bboxRodBufDir = geomRodBufDir.boundingBox()
            bboxRodBufEsq = geomRodBufEsq.boundingBox()

            # Iterando sobre os índices espaciais dos edifícios, para analisar quais índices intersectam o bounding box
            # da rodovia buffada, será feita duas iterações então:
            # A primeira analisando o edifício e o buffer da direita e o segundo analisando o edifício e o buffer da esquerda.
            for idEdificio in edifIndiceEspacial.intersects(bboxRodBufDir):
                # Temos os índices dos edifícios que intersectam as camadas buffadas da rodovia na direita,
                # com esses índices vamos acessar a feição no dicionário e armazená-la em uma variável do edifício
                # com o seu buffer em raio.
                featEdiBuf = dictEdiBuffer[idEdificio]

                # Encontrando a geometria dessa feição
                geomEdiBuf = featEdiBuf.geometry()

                # Adicionando na lista o índice do edifício:
                edificiosInt.append(idEdificio)

                # Analisando o predicado espacial e armazenando os edifícios que estão dentro das rodovias buffadas na direita, temos:
                if geomEdiBuf.within(geomRodBufDir):

                    # Adicionando no dicionário do edifício dentro do buffer da direita, pelos índices:
                    dictEdiDentroBufDir[idEdificio] = featureRod.id()

                    # Analisando a distância entre a rodovia e o edifício, sem o buffer, temos:
                    dist = dictEdificios[idEdificio].geometry().distance(
                        featureRod.geometry())

                    # Verificando se o edificio já foi cadastrado no dicionário das distâncias:
                    # Onde será adicionado como chave a id do edifício e como valor um dicionário que irá conter
                    # o id da rodovia e a distância correspondente.
                    if idEdificio not in dictDistEdiRodoDir:
                        dictDistEdiRodoDir[idEdificio] = {
                            featureRod.id(): dist}
                    # Caso o edifício já esteja cadastrado, podemos fazer:
                    else:
                        # Onde será acrescido a "id" da rodovia e a distância
                        dictDistEdiRodoDir[idEdificio][featureRod.id()] = dist

                # Analisando o caso do edifício não estar dentro da geometria, mas estar intersectando:
                else:
                    # Adicionando no dicionário criado para analisar os edifícios que intersectam o da direita:
                    dictEdiIntBufDir[idEdificio] = featureRod.id()
                    # A importância de se ter esse dicionário e analisar posteriormente os edifícios que estão sofrendo intersecção
                    # tanto do buffer da esquerda quanto da direita

                    # Analisando agora o fato da distância do edifício para a rodovia for menor que a permitida
                    # A distância permitida seria 12.5 (metade da rodovia) + 12.5 * (2) ** (1/2) (metade da diagonal do quadrado)
                    dist = dictEdificios[idEdificio].geometry().distance(
                        featureRod.geometry())

                    # Analisando exatamente esse condição, temos:
                    if dist < (12.5 + 12.5 * (2) ** (1/2)):
                        # Podemos armazenar esse edifício no dicionário que está dentro do buffer da rodovia:
                        dictEdiDentroBufDir[idEdificio] = featureRod.id()

                        # Se o id do edifício não foi ainda armazenado no dicionário, será adicionado
                        if idEdificio not in dictDistEdiRodoDir:
                            dictDistEdiRodoDir[idEdificio] = {
                                featureRod.id(): dist}
                        # Caso o edifício já esteja cadastrado, podemos fazer:
                        else:
                            # Onde será acrescido a "id" da rodovia e a distância
                            dictDistEdiRodoDir[idEdificio][featureRod.id(
                            )] = dist

            # Realizando a segunda etapa, analisar os edifícios e o buffer da esquerda:
            for idEdificioEsq in edifIndiceEspacial.intersects(bboxRodBufEsq):
                # Temos os índices dos edifícios que intersectam com o buffer da rodovia da esquerda com essa iteração,
                # vamos criar uma variável para puxar do dicionário das feições pelo índice do buffer de raio no edifício
                # e colocar em uma variável.
                featEdiBufEsq = dictEdiBuffer[idEdificioEsq]

                # Encontrando a geometria dessa feição:
                geomEdiBufEsq = featEdiBufEsq.geometry()

                # Adicionando na lista o índice do edifício:
                edificiosInt.append(idEdificioEsq)

                # Analisando o predicado espacial e armazenando os edifícios que estão dentro das rodovias buffadas na esquerda,
                # temos:
                if geomEdiBufEsq.within(geomRodBufEsq):
                    # Adicionando no dicionário do edíficio dentro do buffer da esquerda, pelos índices:
                    dictEdiDentroBufEsq[idEdificioEsq] = featureRod.id()

                    # Analisando a distância entre o edíficio e a rodovia, ambos sem o buffer, temos:
                    distEsq = dictEdificios[idEdificioEsq].geometry().distance(
                        featureRod.geometry())

                    # Verificando se o edifício já foi cadastrado no dicionário das distâncias:
                    # Onde será adicionado como chave a id do edifício e como valor um dicionário que
                    # irá o id da rodovia e a distância obtida.
                    if idEdificioEsq not in dictDistEdiRodoEsq:
                        dictDistEdiRodoEsq[idEdificioEsq] = {
                            featureRod.id(): distEsq}
                    # Caso o edifício já esteja cadastrado, podemos fazer:
                    else:
                        # Onde será acrescido a "id" da rodovia e a distância
                        dictDistEdiRodoEsq[idEdificioEsq][featureRod.id(
                        )] = distEsq

                # Analisando o caso do edifício não estar dentro da geometria, mas estar intersectando:
                else:
                    # Adicionando no dicionário criado para analisar os edifícios que intersectam o da direita:
                    dictEdiIntBufEsq[idEdificioEsq] = featureRod.id()
                    # A importância de se ter esse dicionário e analisar posteriormente os edifícios que estão sofrendo intersecção
                    # tanto do buffer da esquerda quanto da direita

                    # Analisando agora o caso da distância do edifício para a rodovia ser menor que a permitida
                    # A distância mínima permitida seria igual a 12.5 (metade do tamanho da rodovia) somado com
                    # 12.5 * (2) ** (1/2) (metade da diagonal do quadrado)
                    distEsq = dictEdificios[idEdificioEsq].geometry().distance(
                        featureRod.geometry())

                    # Analisando exatamente essa condição, temos
                    if distEsq < (12.5 + 12.5 * (2) ** (1/2)):
                        # Podemos adicionar esse edifício que está dentro do buffer da rodovia:
                        dictEdiDentroBufEsq[idEdificioEsq] = featureRod.id()

                        # Verificando se o edifício já foi cadastrado no dicionário das distâncias:
                        # Onde será adicionado como chave a id do edifício e como valor um dicionário que
                        # irá o id da rodovia e a distância obtida.
                        if idEdificioEsq not in dictDistEdiRodoEsq:
                            dictDistEdiRodoEsq[idEdificioEsq] = {
                                featureRod.id(): distEsq}
                        # Caso o edifício já esteja cadastrado, podemos fazer:
                        else:
                            # Onde será acrescido a "id" da rodovia e a distância
                            dictDistEdiRodoEsq[idEdificioEsq][featureRod.id(
                            )] = distEsq

        # Multistepfeedback
        multiStepFeedback.setCurrentStep(4)

        # Armazenando em variáveis as listas das chaves presentes nos dicionário de interseção e de contido:
        listaIdEdiInBufDir = list(dictEdiDentroBufDir.keys())
        listaIdEdiIntBufDir = list(dictEdiIntBufDir.keys())
        listaIdEdiInBufEsq = list(dictEdiDentroBufEsq.keys())
        listaIdEdiIntBufEsq = list(dictEdiIntBufEsq.keys())

        # Criando uma lista para armazenar os valores de id que estão presentes em direções diferentes, por exemplo,
        # um id está na listaIdEdiInBufDir e também está dentro de listaIdEdiInBufEsq ou listaIdEdiIntBufEsq, ou o caso
        # em que temos o índice em listaIdEdiIntBufDir e também está dentro de listaIdEdiInBufEsq ou listaIdEdiIntBufEsq.
        listaDuasDirecoes = []

        # Iterando sobre os índices inicialmente de listaIdEdiInBufDir e analisando se está presente nas listas de índices da esquerda,
        # caso esteja, será adicionado a lista criada chamada de listaDuasDirecoes.
        for idInDir in listaIdEdiInBufDir:
            if idInDir in listaIdEdiInBufEsq:
                listaDuasDirecoes.append(idInDir)
            elif idInDir in listaIdEdiIntBufEsq:
                listaDuasDirecoes.append(idInDir)

        # Iterando agora sobre os índices de listaIdEdiIntBufDir e analisando se está presente nas listas de índices da esquerda,
        # caso esteja, será adicionado a lista criada chamada de listaDuasDirecoes.
        for idIn in listaIdEdiIntBufDir:
            if idIn in listaIdEdiInBufEsq:
                listaDuasDirecoes.append(idIn)
            elif idIn in listaIdEdiIntBufEsq:
                listaDuasDirecoes.append(idIn)

        # Criando o dicionário para as feições que substituirão:
        dictEdificiosOri = {}

        # Percorrendo agora o dicionário dos edifícios que estão dentro da rodovia buffada na direita:
        for current4, (id, idRodovia) in enumerate(dictEdiDentroBufDir.items()):
            # Caso o usuário deseje parar o processo, teremos:
            if feedback.isCanceled():
                break
            
            # Analisando se o índice também não está dentro da listaDuasDirecoes, iremos fazer as devidas alterações
            #if id in listaDuasDirecoes:
            #    continue
            
            # Caso não esteja na lista, vamos armazenar tanto o ponto que representa o edifício quanto a feature de linestring
            # que representa a rodovia e armazenando em uma variável, puxando pelo dicionário de id's
            
            # Agora precisa ser analisado o fato do edifício ter consigo mais de uma correspondência no dicionário das distâncias
            # (dictDistEdiRodoDir), para assim, escolher a menor e pegar o id da linestring da rodovia que representa essa menor
            # distância.
            
            # Criando uma variável de menor distância que irá percorrer os items do dicionário que corresponde a chave do id analisado
            # na presente iteração
            if len(dictDistEdiRodoDir[id].items()) > 1:
                menor_dist = 9999
                for i in list(dictDistEdiRodoDir[id].items()):
                    if i[1] < menor_dist:
                        menor_dist = i[1]
                        idProcurado = i[0] # Id procurado da feição da rodovia, que será puxado do dicionário das rodovias.
            
                # Armazenando em uma variável a feição da rodovia puxando a feição pelo id, no dicionário criado:
                fRodovia = dictRodovias[idProcurado]
            else:
                # Caso só tenha uma feição com distância dentro, então é o id da própria iteração:
                fRodovia = dictRodovias[idRodovia]
            
            # Armazenando em uma variável a feição do edifício puxando a feição pelo id, no dicionário criado:
            fEdificio = dictEdificios[id]

            # Coletando as geometrias dessas feições, teremos:
            gRodovia = fRodovia.geometry()
            gEdificio = fEdificio.geometry()

            # Encontrando as coordenadas tranto da geometria do edifício, como das coordenadas do ínicio e do
            # final da geometria da rodovia:
            # Separando nas coordenadas x e y de cada ponto, tanto do ínicio quanto do final.
            xInicRodDir = float(f"{gRodovia}".split("(")[1].split(")")[0].split(", ")[0].split(" ")[0])          
            yInicRodDir = float(f"{gRodovia}".split("(")[1].split(")")[0].split(", ")[0].split(" ")[1])          
            xFinRodDir = float(f"{gRodovia}".split("(")[1].split(")")[0].split(", ")[1].split(" ")[0])
            yFinRodDir = float(f"{gRodovia}".split("(")[1].split(")")[0].split(", ")[1].split(" ")[1])

            # Para a coordenada do edifício, temos:
            xEdiDir = float(f"{gEdificio}".split("((")[1].split("))")[0].split(" ")[0])
            yEdiDir = float(f"{gEdificio}".split("((")[1].split("))")[0].split(" ")[1])

            # Encontrando a equação da reta da linestring, temos:
            # Coeficiente angular da linestring, por meio das coordenadas finais e iniciais:
            coefAng = (yFinRodDir - yInicRodDir) / (xFinRodDir - xInicRodDir)

            coefAngPerp = -(coefAng ** (-1)) # Coeficiente angular da reta que está na perpendicular da linestring da menor distância
            # direção que será movida o edifício.

            # Encontrando o ponto que quando se traça a perpendicular pelo edifício, corta a rodovia, temos:
            # Chamando os pontos da coordenada de xOrt e yOrt:
            xOrt = ((yEdiDir - yFinRodDir) - (coefAngPerp * xEdiDir) + (coefAng * xFinRodDir)) / (coefAng - coefAngPerp)
            yOrt = yEdiDir + coefAngPerp * (xOrt - xEdiDir)

            # Encontrando o vetor diretor que deverá ser feito o deslocamento, dado por:
            xVetorDeslocamento = (xEdiDir - xOrt)
            yVetorDeslocamento = (yEdiDir - yOrt)
            

            # Encontrando a constante 't' que se deve multiplicar o vetor direitor para que se consiga uma distância
            # necessária para calcular a coordenada onde o centro do edifício vai ficar para que não se intersecte mais
            # com a rodovia
            t = ((12.7 + 12.5 * (2) ** (1/2)) ** 2 / (xVetorDeslocamento ** 2 + yVetorDeslocamento ** 2)) ** (1/2)

            # De posse do valor da constante t, teremos então as novas coordenadas do edifício:
            xEdi = t * xVetorDeslocamento + xOrt
            yEdi = t * yVetorDeslocamento + yOrt

            # A distância do deslocamento efetivo do ponto será dado pela distância que vai se colocar da rodovia menos a
            # a distância que ele estava anteriormente
            distanciaDeslocamento = (12.7 + 12.5 * (2) ** (1/2)) - dictDistEdiRodoDir[id][fRodovia.id()]

            # Verificando se a distancia de deslocamento do bloco foi menor que a distância máxima colocada no input
            if distanciaDeslocamento < dist_deslocamento:
                
                # Adicionando no dicionário criado para adicionar as feições com as suas respectivas distâncias de deslocamento:
                dictEdiDistancia[id] = distanciaDeslocamento
                # Teremos então o controle de quanto cada feição está se deslocando

                # Criando uma feature que será adicionada ao dicionário como sendo a nova correspondência 
                # no dicionário que foi criado anteriormente para as edificações
                featOri = QgsFeature()
                featOri.setGeometry(QgsGeometry.fromPointXY(QgsPointXY(xEdi, yEdi)))

                # Adicionando no dicionário como sendo a feature original, temos:
                dictEdificiosOri[id] = featOri

                # Adicionando no dicionário como ed

                # Criando a feição que será adicionado na camada de saída
                featSaida = QgsFeature()
                featSaida.setGeometry(QgsGeometry.fromPointXY(QgsPointXY(xEdi, yEdi)).buffer(25, -1))

                # Adicionando no dicionário como edifício deslocado, temos:
                dictEdificiosDeslocados[id] = featSaida

                # Adicionando na camada de saída:
                #sink.addFeature(featSaida, QgsFeatureSink.FastInsert)
        
        # Multistepfeedback
        multiStepFeedback.setCurrentStep(5)
        
        # Percorrendo agora o dicionário dos edifícios que estão dentro da rodovia buffada na esquerda:
        for current5, (idE, idR) in enumerate(dictEdiDentroBufEsq.items()):
            # Caso o usuário deseje para o processamento:
            if feedback.isCanceled():
                break
            
            # Analisando também se o índice não está presente na listaDuasDirecoes, iremos fazer as devidas alterações:
            #if idE in listaDuasDirecoes:
            #    continue
            
            # Caso o id não esteja na lista acima, iremos armazenar as features dentro de variáveis para a analise das suas
            # geometrias.

            # Agora é necessário analisar no dicionário que possui o índice das features dos edifícios e analisar se elas
            # correspondem a mais de uma feature de rodovia e assim pegar a menor e o índice da rodovia correspondente, 
            # pelo dicionário (dictDistEdiRodoEsq)
            
            if len(dictDistEdiRodoEsq[idE].items()) > 1:
                menor_dist_esq = 9999
                for i in list(dictDistEdiRodoEsq[idE].items()):
                    if i[1] < menor_dist_esq:
                        menor_dist_esq = i[1]
                        idProcuradaEsq = i[0] # Id procurado das rodovias, que será puxado do dicionário das rodovias

                        # Adicionando em uma variável a feição da rodovia encontrada:
                        fRodoviaEsq = dictRodovias[idProcuradaEsq]
            else:
                # Caso só tenha apenas uma feição dentro dos valores com a sua respectiva distância, podemos fazer:
                fRodoviaEsq = dictRodovias[idR]

            # Armazenando em uma variável a feature do edifício, puxando do dicionário dos edifícios:
            fEdificioEsq = dictEdificios[idE]

            # Gerando então as geometrias de cada uma dessas features, temos:
            gEdificioEsq = fEdificioEsq.geometry()
            gRodoviaEsq = fRodoviaEsq.geometry()

            # Encontrando as coordenadas dos edifícios, assim como as coordenadas do ínicio e do final das linestrings que 
            # representam as rodovias, temos:
            # Separando nas coordenadas x e y, tanto do ínicio como do final:
            xInicRodEsq = float(f"{gRodoviaEsq}".split("(")[1].split(")")[0].split(", ")[0].split(" ")[0])
            yInicRodEsq = float(f"{gRodoviaEsq}".split("(")[1].split(")")[0].split(", ")[0].split(" ")[1])
            xFinRodEsq = float(f"{gRodoviaEsq}".split("(")[1].split(")")[0].split(", ")[1].split(" ")[0])
            yFinRodEsq = float(f"{gRodoviaEsq}".split("(")[1].split(")")[0].split(", ")[1].split(" ")[1])
                    
            # Para as coordenadas do edifício, temos:
            xEdiEsq = float(f"{gEdificioEsq}".split("((")[1].split("))")[0].split(" ")[0])
            yEdiEsq = float(f"{gEdificioEsq}".split("((")[1].split("))")[0].split(" ")[1])
            

            # Encontrando a equação da reta que rege a linestring da rodovia, temos:
            # Encontrando inicialmente o coeficiente angular da reta:
            coefAngEsq = (yFinRodEsq - yInicRodEsq) / (xFinRodEsq - xInicRodEsq)

            coefAngPerpEsq = -(coefAngEsq ** (-1)) # Coeficiente angular da reta perpendicular a reta da linestring que possui a
            # direção igual a direção que se deverá deslocar o edifício (ortogonalmente à rodovia).

            # Encontrando o ponto na linestring que se encontra quando se traça a perpendicular a partir do edifício
            # na rodovia, temos:
            # Chamando de xOrtEsq e yOrtEsq esses pontos:
            xOrtEsq = ((yEdiEsq - yFinRodEsq) - (coefAngPerpEsq * xEdiEsq) + (coefAngEsq * xFinRodEsq)) / (coefAngEsq - coefAngPerpEsq)
            yOrtEsq = yEdiEsq + coefAngPerpEsq * (xOrtEsq - xEdiEsq)

            # Encontrando o vetor deslocamento que deverá ser realizado o deslocamento do edifício:
            xVetorDeslocamentoEsq = (xEdiEsq - xOrtEsq)
            yVetorDeslocamentoEsq = (yEdiEsq - yOrtEsq)

            # Calculando a constante 'tEsq' que deverá se multiplicar o vetor deslocamento para que seja essas a nova coordenada do 
            # edifício para que esse não intersecte mais a rodovia, temos:
            tEsq = ((12.7 + 12.5 * (2) ** (1/2)) ** (2) / (xVetorDeslocamentoEsq ** 2 + yVetorDeslocamentoEsq ** 2)) ** (1/2)

            # De posse do valor da constante que se deve multiplicar o vetor diretor, podemos multiplicar pelo vetor diretor, 
            # para que se consiga encontrar as novas coordenadas do edifício:
            xE = tEsq * xVetorDeslocamentoEsq + xOrtEsq
            yE = tEsq * yVetorDeslocamentoEsq + yOrtEsq

            # A distância que esse edifício vai percorrer efetivamente vai ser a distância que ele ficará da rodovia menos a 
            # distância que ele estava anteriormente da rodovia:
            distanciaDeslocamentoEsq = (12.7 + 12.5 * (2) ** (1/2)) - dictDistEdiRodoEsq[idE][fRodoviaEsq.id()]

            # Verificando se a distancia de deslocamento do bloco foi menor que a distância máxima colocada no input
            if distanciaDeslocamentoEsq < dist_deslocamento:
                # Adicionando no dicionário de distâncias de cada feição, para se conseguir verificar a distância total que cada
                # feição está se deslocando
                dictEdiDistancia[idE] = distanciaDeslocamentoEsq
                # Teremos então o controle de quanto a feição está se deslocando

                # Criando a feição que será adicionado como sendo a nova feição do índice no dicionário original
                featOri = QgsFeature()
                featOri.setGeometry(QgsGeometry.fromPointXY(QgsPointXY(xE, yE)))

                # Colocando no dicionário
                dictEdificiosOri[idE] = featOri

                # Criando a feição que será adicionado na camada de saída, temos:
                featSaidaEsq = QgsFeature()
                featSaidaEsq.setGeometry(QgsGeometry.fromPointXY(QgsPointXY(xE, yE)).buffer(25, -1))

                # Adicionando no dicionário como edifício deslocado
                dictEdificiosDeslocados[idE] = featSaidaEsq

                # Adicionando na camada de saída:
                #sink.addFeature(featSaidaEsq, QgsFeatureSink.FastInsert)
        
        # Multistepfeedback
        multiStepFeedback.setCurrentStep(6)

        # Iterando sobre a lista dos pontos que são pontas na feature, realizando um buffer para conseguir o edifício
        # que está nessa ponta
        for current7, ponta in enumerate(listaPonta):
            feature = QgsFeature()
            feature.setGeometry(QgsGeometry.fromWkt(ponta).buffer(30, 200))
            # Criando o seu bounding box
            bboxPonta = feature.geometry().boundingBox()
            # Iterando sobre os índices dos edificíos para verificar qual está no contexto espacial:
            for idEdH in edifIndiceEspacial.intersects(bboxPonta):
                # Descobrindo o vetor que se deverá deslocar o edifício que será dado basicamente
                # pela diferença vetorial entre a posição do edifício e a posição da ponta:
                # Coordenadas do ponto do edifício:
                xEdiH = float(f"{dictEdificios[idEdH].geometry().asWkt()}".split("((")[1].split("))")[0].split(" ")[0])
                yEdiH = float(f"{dictEdificios[idEdH].geometry().asWkt()}".split("((")[1].split("))")[0].split(" ")[1])
                
                # Coordenadas da ponta:
                xPonta = float(ponta.split("(")[1].split(")")[0].split(" ")[0])
                yPonta = float(ponta.split("(")[1].split(")")[0].split(" ")[1])

                # Portando o vetor deslocamento será:
                desl = (xEdiH - xPonta, yEdiH - yPonta)

                # Calculando a constante que se deve multiplicar para que se tenha o deslocamento do edifício
                # para que não se intersecte mais, será dado por:
                t = ((18 + 12.5 * (2) ** (1/2)) ** 2 / (desl[0] ** 2 + desl[1] ** 2)) ** (1/2)

                # Deslocando então o edifício com uma soma vetorial:
                xEdi = t * desl[0] + xPonta
                yEdi = t * desl[1] + yPonta

                # A distância que o edifício deslocará de fato será:
                realDist = (18 + 12.5 * (2) ** (1/2)) - (desl[0] ** 2 + desl[1] ** 2) ** (1/2)

                if realDist < dist_deslocamento:
                    # Adicionando a feature do edifício no dicionário com a sua distância deslocada, temos:
                    dictEdiDistancia[idEdH] = realDist
                    # Teremos então o controle de quanto esse edifício deslocou

                    # Pegando a feição original e adicionando na lista como essa nova
                    featOri = QgsFeature()
                    featOri.setGeometry(QgsGeometry.fromPointXY(QgsPointXY(xEdi, yEdi)))

                    # Substituindo a feição que estava antes por essa agora do featOri
                    dictEdificiosOri[idEdH] = featOri

                    # Criando a feição que será adicionado na camada de saída, temos:
                    featSaida = QgsFeature()
                    featSaida.setGeometry(QgsGeometry.fromPointXY(QgsPointXY(xEdi, yEdi)).buffer(25, -1))

                    # Analisando se o índice já se encontra dentro do dicionário para que não tenha dois deslocamentos de um mesmo
                    # edifício, temos:
                    if idEdH not in dictEdificiosDeslocados:
                        dictEdificiosDeslocados[idEdH] = featSaida
                    
                    # Adicionando na camada de saída:
                    #sink.addFeature(featSaida, QgsFeatureSink.FastInsert)

        # Multistepfeedback
        multiStepFeedback.setCurrentStep(7)
        
        for current8, id in enumerate(list(dictEdificios.keys())):
            if id not in list(dictEdificiosDeslocados.keys()):
                featSaida = QgsFeature()
                featSaida.setGeometry(QgsGeometry(dictEdificios[id].geometry().buffer(25, -1)))
                dictEdificiosDeslocados[id] = featSaida
            
            if id not in list(dictEdificiosOri.keys()):
                featOri = QgsFeature()
                xOri = float(f"{dictEdificios[id].geometry().asWkt()}".split("((")[1].split("))")[0].split(" ")[0])
                yOri = float(f"{dictEdificios[id].geometry().asWkt()}".split("((")[1].split("))")[0].split(" ")[1])
                featOri.setGeometry(QgsGeometry.fromPointXY(QgsPointXY(xOri, yOri)))
                
                dictEdificiosOri[id] = featOri
        
        # Multistepfeedback
        multiStepFeedback.setCurrentStep(8)
        
        # Criando uma lista para armazenar os índices que estão nas duas vias buffadas
        listaEdiDuas = []

        # Iterando para saber quais edifícios estão interseccionando as duas rodovias:
        for current9, idV in enumerate(list(dictEdificios.keys())):
            if idV in dictEdiIntBufDir and idV in dictEdiIntBufEsq:
                listaEdiDuas.append(idV)

        edificiosInt = set(edificiosInt)
        edificiosInt = list(edificiosInt)

        # Multistepfeedback
        multiStepFeedback.setCurrentStep(9)
        
        # Iterando sobre os edifícios deslocados e iremos ver se os edíficos deslocados intersectam um 
        # ao outro
        itera = 0
        while itera != 100:
            for current10, idG in enumerate(list(dictEdificios.keys())):
                # Caso o usuário deseje parar o processo:
                if feedback.isCanceled():
                    break

                if idG not in edificiosInt:
                    continue

                for current11, idH in enumerate(list(dictEdificios.keys())):
                    # Caso o usuário deseje parar o processo:
                    if feedback.isCanceled():
                        break

                    # Se os índices são os mesmos continue
                    if idG == idH:
                        continue
                    
                    xRef = float(f"{dictEdificiosOri[idG].geometry().asWkt()}".split("(")[1].split(")")[0].split(" ")[0])
                    yRef = float(f"{dictEdificiosOri[idG].geometry().asWkt()}".split("(")[1].split(")")[0].split(" ")[1])

                    xDesl = float(f"{dictEdificiosOri[idH].geometry().asWkt()}".split("(")[1].split(")")[0].split(" ")[0])
                    yDesl = float(f"{dictEdificiosOri[idH].geometry().asWkt()}".split("(")[1].split(")")[0].split(" ")[1])

                    distI = ((xDesl - xRef) ** 2 + (yDesl - yRef) ** 2) ** (1/2)


                    if distI > 0 and distI < 35:
                
                        vD = (xDesl - xRef, yDesl - yRef)

                        # A constante que deverá se deslocar será dada por:
                        tD = (35 ** (2) / (vD[0] ** 2 + vD[1] ** 2)) ** (1/2)

                        # Logo a nova coordenada do ponto do edifício será dada por:
                        xDesl = tD * vD[0] + xRef
                        yDesl = tD * vD[1] + yRef    

                        # Criando a nova feição que receberá para o índice atual da iteração essas coordenadas, teremos:
                        novaFeat = QgsFeature()
                        novaFeat.setGeometry(QgsGeometry.fromPointXY(QgsPointXY(xDesl, yDesl)))

                        adicionar = True
                        
                        for feat in rodovia.getFeatures():
                            dist = novaFeat.geometry().distance(feat.geometry())

                            if dist < (12.5 + 12.5 * (2) ** (1/2)):
                                adicionar = False

                        # Adicionando como sendo essa feature a feature do id da iteração
                        if adicionar:
                            dictEdificiosOri[idH] = novaFeat

            itera += 1
        # Multistepfeedback
        multiStepFeedback.setCurrentStep(10)


        for id in list(dictEdificiosOri.keys()):
            featSaida = QgsFeature()
            featSaida.setGeometry(dictEdificiosOri[id].geometry())

            sink.addFeature(featSaida, QgsFeatureSink.FastInsert)


        # Armazenando para que se consiga mudar o estilo da camada de saída, temos:
        self.dest_id=dest_id
   
        # Retornando a saída das feições de resultado
        return {self.OUTPUT: dest_id}


    # Definindo a função para que se coloque na camada de saída o estilo do arquivo .qml das edificações
    def postProcessAlgorithm(self, context, feedback):
        output = QgsProcessingUtils.mapLayerFromString(self.dest_id, context)
        path='C:\\Users\\mathe\\OneDrive\\Área de Trabalho\\Trabalhos\\ProgAplicada\\Projeto3\\dados\\edificacoes.qml'
        output.loadNamedStyle(path)
        output.triggerRepaint()
        return {self.OUTPUT: self.dest_id}

    def name(self):
        """
        Returns the algorithm name, used for identifying the algorithm. This
        string should be fixed for the algorithm, and must not be localised.
        The name should be unique within each provider. Names should contain
        lowercase alphanumeric characters only and no spaces or other
        formatting characters.
        """
        return 'Solução do Projeto 3'

    def displayName(self):
        """
        Returns the translated algorithm name, which should be used for any
        user-visible display of the algorithm name.
        """
        return self.tr(self.name())

    def group(self):
        """
        Returns the name of the group this algorithm belongs to. This string
        should be localised.
        """
        return self.tr(self.groupId())

    def groupId(self):
        """
        Returns the unique ID of the group this algorithm belongs to. This
        string should be fixed for the algorithm, and must not be localised.
        The group id should be unique within each provider. Group id should
        contain lowercase alphanumeric characters only and no spaces or other
        formatting characters.
        """
        return 'Projeto 3'

    def tr(self, string):
        return QCoreApplication.translate('Processing', string)

    def createInstance(self):
        return Projeto3Solucao()