# -*- coding: utf-8 -*-

"""
/***************************************************************************
 ProgramacaoAplicadaGrupo3
                                 A QGIS plugin
 Solução do Grupo 3
 Generated by Plugin Builder: http://g-sherman.github.io/Qgis-Plugin-Builder/
                              -------------------
        begin                : 2023-05-07
        copyright            : (C) 2023 by Grupo 3
        email                : matheus.silva@ime.eb.br
                               samuel.melo@ime.eb.br
                               reginaldo.filho@ime.eb.br
                               romeu.peris@ime.eb.br
 ***************************************************************************/

/***************************************************************************
 *                                                                         *
 *   This program is free software; you can redistribute it and/or modify  *
 *   it under the terms of the GNU General Public License as published by  *
 *   the Free Software Foundation; either version 2 of the License, or     *
 *   (at your option) any later version.                                   *
 *                                                                         *
 ***************************************************************************/
"""

__author__ = 'Grupo 3'
__date__ = '2023-03-20'
__copyright__ = '(C) 2023 by Grupo 3'

# This will get replaced with a git SHA1 when you do a git archive

__revision__ = '$Format:%H$'

from qgis.PyQt.QtCore import QCoreApplication, QVariant
from qgis.core import (QgsProcessing,
                       QgsFeatureSink,
                       QgsWkbTypes,
                       QgsPointXY,
                       QgsProcessingMultiStepFeedback,
                       QgsField,
                       QgsProcessingParameterNumber,
                       QgsSpatialIndex,
                       QgsProcessingUtils,
                       QgsFeature,
                       QgsProcessingException,
                       QgsProcessingAlgorithm,
                       QgsGeometry,
                       QgsFields,
                       QgsProcessingParameterFeatureSource,
                       QgsProcessingParameterFeatureSink)


class Projeto3Solucao(QgsProcessingAlgorithm):
    """
    Esse algoritmo tem por finalidade solucionar o projeto 3, referente a uma melhor visualização
    espacial das camadas de entrada, que foram a rodovia e os edifícios.
    """

    # Declarando as variáveis que serão utilizadas.
    OUTPUT = 'OUTPUT'
    INPUT_RODOVIAS = 'INPUT_RODOVIAS'
    DISTANCIA_DESLOCAMENTO = 'DISTANCIA_DESLOCAMENTO'
    INPUT_EDIFICIOS = 'INPUT_EDIFICIOS'

    def initAlgorithm(self, config):
        """
        Aqui será iniciado o algoritmo, onde serão adicionado os parâmetros declarados anteriormente.
        """

        # Adicionando inicialmente o parâmetro das rodovias
        self.addParameter(
            QgsProcessingParameterFeatureSource(
                self.INPUT_RODOVIAS,
                self.tr('Camada das rodovias'),
                [QgsProcessing.TypeVectorLine]
            )
        )
        
        # Adicionando o parâmetro dos edifícios
        self.addParameter(
            QgsProcessingParameterFeatureSource(
                self.INPUT_EDIFICIOS,
                self.tr('Camada dos edícios'),
                [QgsProcessing.TypeVectorPoint]
            )
        )
        
        # Adicionando o parâmetro da distância máxima
        self.addParameter(
            QgsProcessingParameterNumber(
                self.DISTANCIA_DESLOCAMENTO,
                self.tr('Distância de deslocamento'),
                type=QgsProcessingParameterNumber.Double

            )
        )

        # Adicionando o parâmetro da camada de saída
        self.addParameter(
            QgsProcessingParameterFeatureSink(
                self.OUTPUT,
                self.tr('Output layer')
            )
        )


    def processAlgorithm(self, parameters, context, feedback):
        """
        Aqui será feita o processamento do algoritmo.
        """

        # Alocando na variável edificios a camada de entrada dos edifícios, temos:
        edificios = self.parameterAsSource(parameters, self.INPUT_EDIFICIOS, context)

        # Alocando na variável rodovia a camada de entrada da rodovia, temos:
        rodovia = self.parameterAsSource(parameters, self.INPUT_RODOVIAS, context)

        # Alocando na variável dist_deslocamento o número passado como valor no processing:
        dist_deslocamento = self.parameterAsDouble(parameters, self.DISTANCIA_DESLOCAMENTO, context)

        # Alocando a camada de saída na variável sink
        (sink, dest_id) = self.parameterAsSink(parameters, self.OUTPUT,
                context, edificios.fields(), QgsWkbTypes.Point, rodovia.sourceCrs())
        

        # Adicionando o multistepfeedback para poder mostrar na tela o carregamento
        multiStepFeedback = QgsProcessingMultiStepFeedback(10, feedback)
        multiStepFeedback.setCurrentStep(0)
        multiStepFeedback.setProgressText(self.tr("Verificando estrtutura"))
        
        
        # Criando um dicionário que vai armazenar como chave a feature das rodovias e dos edifícios, temos:
        dictRodovias = {}
        dictEdificios = {}
        # Criando a variável que vai armazenar o índice espacial tanto da rodovia quanto dos edifícios, temos:
        rodoIndiceEspacial = QgsSpatialIndex()
        edifIndiceEspacial = QgsSpatialIndex()

        # Iterando para armazenar no dicionário e no indice espacial:
        for rodo in rodovia.getFeatures():
            dictRodovias[rodo.id()] = rodo
            rodoIndiceEspacial.addFeature(rodo)

        for edif in edificios.getFeatures():
            dictEdificios[edif.id()] = edif
            edifIndiceEspacial.addFeature(edif)
    

        # Criando um dicionário para associar o indice da feature da rodovia com o buffer que será aplicado
        # nessa parte da rodovia, tanto na direita quanto na esquerda:
        dictBufferEsquerda = {}
        dictBufferDireita = {}
        
        # Essa iteração inicial é apenas para armazenar o índice da feature analisada como chave do dicionário e 
        # a feature com o buffer no valor do dicionário.
        for current, feature in enumerate(rodovia.getFeatures()):
            # Parar o processing caso o usuário deseje.
            if feedback.isCanceled():
                break
            
            # Criando a feature que irá receber o buffer da direita e armazenando essa feição com o índice da feature
            # correspondente inicialmente.
            # Foi aplicado um buffer tanto unilateral quanto um buffer pra pegar toda a limitação da rodovia, cobrindo
            # assim toda a extensão da via e a parte unilateral específicada.
            featBufferDir = QgsFeature()
            featBufferDir.setGeometry(feature.geometry().singleSidedBuffer((12.5 + 12.5 * (2) ** (1/2)), -1, QgsGeometry.SideRight).buffer(10, -1))
            #sink.addFeature(featBufferDir, QgsFeatureSink.FastInsert)

            # Armazenando no dicionário criado para o buffer da direita:
            dictBufferDireita[feature.id()] = featBufferDir

            # Criando a feature que irá receber o buffer da esquerda e armazenando essa feição com o índice da 
            # feature correspondente inicialmente.
            # Foi aplicado um buffer tanto unilateral quanto um buffer pra pegar toda a limitação da rodovia, cobrindo
            # assim toda a extensão da via e a parte unilateral específicada.
            featBufferEsq = QgsFeature()
            featBufferEsq.setGeometry(feature.geometry().singleSidedBuffer((12.5 + 12.5 * (2) ** (1/2)), -1, QgsGeometry.SideLeft).buffer(10, -1))
            #sink.addFeature(featBufferEsq, QgsFeatureSink.FastInsert)

            # Armazenando no dicionário criado para o buffer da esquerda:
            dictBufferEsquerda[feature.id()] = featBufferEsq
        
        # Multistepfeedback
        multiStepFeedback.setCurrentStep(1)
        
        # Criando o dicionário que irá armazenar os edifícios com o buffer da circunferência, com o mesmo id da feição normal
        dictEdiBuffer = {}

        for current2, edi in enumerate(edificios.getFeatures()):
            # Parar o processing caso o usuário deseje.
            if feedback.isCanceled():
                break

            # Criando a feição que irá receber o buffer e será armazenada no dicionário
            featEdiBuffer = QgsFeature()
            featEdiBuffer.setGeometry(edi.geometry().buffer(12.5 * (2) ** (1/2), 200))

            # Armazenando no dicionário criado para o buffer da circunferência circunscrita no ponto:
            dictEdiBuffer[edi.id()] = featEdiBuffer
        
        # Multistepfeedback
        multiStepFeedback.setCurrentStep(2)

        # Criando dicionários para armazenar quais edifícios estão dentro do buffer da direita, quais edifícios estão
        # dentro do buffer da esquerda, quais edifícios intersectam o da direita e quais edifícios intersectam o da esquerda,
        # um dicionário para armazenar quanto o ponto foi deslocado pelo seu índice, para que não extrapole a distância e por fim
        # um dicionário para armazenar a distância entre a rodovia e o edifício para verificar qual a menor, totalizando 6 dicionários:
        dictEdiDentroBufDir = {}
        dictEdiDentroBufEsq = {}
        dictEdiIntBufDir = {}
        dictEdiIntBufEsq = {}
        dictEdiDistancia = {}
        dictDistEdiRodoDir = {}
        dictDistEdiRodoEsq = {}

        # Como forma de analisar as bifurcações que ocorre em algumas partes da rodovia e nesse espaço entre as vias possui 
        # edifícios, iremos agora encontrar esses pontos, onde isso ocorre para posteriormente aplicar um buffer e analisar
        # quais edifícios se encontram na sua região:
        dictBifurcacao = {}

        # Criando a lista dos edifícios que foram deslocados, para que não se tenha mais de um deslocamento com o mesmo 
        # edifício, onde a chave será o índice do edifício e como valor será a feature buffada, por enquanto.
        dictEdificiosDeslocados = {}

        for current6, feaRodo in enumerate(rodovia.getFeatures()):
            # Pegando os vértices dessa feição e armazenando em uma lista:
            listVert = list(feaRodo.geometry().vertices())
            primVert = listVert[0]
            ultVert = listVert[-1]

            # Analisando se o vértice já se encontra no dicionário:
            if primVert.asWkt() not in dictBifurcacao:
                dictBifurcacao[primVert.asWkt()] = {"chegando": 0, "saindo": 0}
            if ultVert.asWkt() not in dictBifurcacao:
                dictBifurcacao[ultVert.asWkt()] = {"chegando": 0, "saindo": 0}

            # E logo após passar o if, iremos adicionar um saindo para o primeiro vértice e
            # um chegando para o ultimo vértice
            dictBifurcacao[primVert.asWkt()]["saindo"] += 1
            dictBifurcacao[ultVert.asWkt()]["chegando"] += 1
        
        # Multistepfeedback
        multiStepFeedback.setCurrentStep(3)

        # Verificando dos pontos qual possui soma maior que 2 de chegando e saindo, pois esses serão pontos de 
        # bifurcação:
        # Armazenando os pontos que possuem essa característica na lista abaixo:
        listaBifurca = []
        # Adicionando os pontos que são ponta, para verificar se aplicado um buffer nesse ponto intersecta com algum
        # edifício, temos:
        listaPonta = []

        for items in dictBifurcacao.items():
            chegando = items[1]["chegando"]
            saindo = items[1]["saindo"]

            total = chegando + saindo

            if total > 2:
                listaBifurca.append(items[0])
            elif total == 1:
                listaPonta.append(items[0])
        

        for i in listaBifurca:
            feature = QgsFeature()
            feature.setGeometry(QgsGeometry.fromWkt(i).buffer(12.5, 200))
            #sink.addFeature(feature, QgsFeatureSink.FastInsert)

        # Criando a lista para adicionar o índice dos edifício que fazem intersecção tanto com os dois
        # lados da rodovia, temos:
        edificiosInt = []