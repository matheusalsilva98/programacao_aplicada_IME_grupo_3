# -*- coding: utf-8 -*-

"""
/***************************************************************************
 ProgramacaoAplicadaGrupo3
                                 A QGIS plugin
 Solução do Grupo 3
 Generated by Plugin Builder: http://g-sherman.github.io/Qgis-Plugin-Builder/
                              -------------------
        begin                : 2023-03-20
        copyright            : (C) 2023 by Grupo 3
        email                : matheus.silva@ime.eb.br
                               samuel.melo@ime.eb.br
                               reginaldo.filho@ime.eb.br
                               romeu.peris@ime.eb.br
 ***************************************************************************/

/***************************************************************************
 *                                                                         *
 *   This program is free software; you can redistribute it and/or modify  *
 *   it under the terms of the GNU General Public License as published by  *
 *   the Free Software Foundation; either version 2 of the License, or     *
 *   (at your option) any later version.                                   *
 *                                                                         *
 ***************************************************************************/
"""

__author__ = 'Grupo 3'
__date__ = '2023-03-20'
__copyright__ = '(C) 2023 by Grupo 3'

# This will get replaced with a git SHA1 when you do a git archive

__revision__ = '$Format:%H$'

from collections import Counter
from qgis.PyQt.QtCore import QCoreApplication, QVariant
from qgis.core import (QgsProcessing,
                       QgsFeatureSink,
                       QgsFields,
                       QgsProcessingMultiStepFeedback,
                       QgsSpatialIndex,
                       QgsFeature,
                       QgsGeometry,
                       QgsField,
                       QgsWkbTypes,
                       QgsProcessingParameterMultipleLayers,
                       QgsProcessingAlgorithm,
                       QgsProcessingParameterFeatureSource,
                       QgsProcessingParameterFeatureSink)


class Projeto4SolucaoComplementar(QgsProcessingAlgorithm):
    """
    é responsável pelo desenvolvimento do objetivo complementar do Projeto 4
    """

    # Definindo os parâmetros de entrada

    # Definindo o parâmetro de OUTPUT
    OUTPUT = 'OUTPUT'

    # Definindo o parâmetro de INPUT_POLIGONO que será a lista de polígonos
    INPUT_POLIGONO = 'INPUT_POLIGONO'

    # Definindo o parâmetro de INPUT_MOLDURA que será a entrada da moldura
    INPUT_MOLDURA = 'INPUT_MOLDURA'
    

    def initAlgorithm(self, config):
        """
        Aqui vamos definir os input's e output's do algoritmo
        """

        # Adicionando o parâmetro que será a lista de camadas de polígonos analisada
        self.addParameter(
            QgsProcessingParameterMultipleLayers(
                self.INPUT_POLIGONO,
                self.tr('Lista de polígonos'),
                layerType = QgsProcessing.TypeVectorPolygon
            )
        )

        # Adicionando o parâmetro de entrada que será a moldura
        self.addParameter(
            QgsProcessingParameterFeatureSource(
                self.INPUT_MOLDURA,
                self.tr('Moldura'),
                [QgsProcessing.TypeVectorPolygon]
            )
        )

        # Adicionando o parâmetro que será a camada de saída
        self.addParameter(
            QgsProcessingParameterFeatureSink(
                self.OUTPUT,
                self.tr('Camada de saída')
            )
        )

    def processAlgorithm(self, parameters, context, feedback):
        """
        Definindo o processo do algoritmo
        """
        # Colocando na variável 'moldura' o input da camada de moldura que se vai receber
        moldura = self.parameterAsSource(parameters, self.INPUT_MOLDURA, context)

        # Colocando na variável 'listaCamadasLinhas' a camada de INPUT das linhas
        listaCamadasPoligonos = self.parameterAsLayerList(parameters, self.INPUT_POLIGONO, context)

        # Criando a variável que irá receber os atributos na tabela de atributo
        fields = QgsFields()

        # Adicionando o campo do tipo de string que irá receber a mensagem de erro
        fields.append(QgsField("tipo_de_erro", QVariant.String))

        # Colocando na variável a camada de saída
        (sink, dest_id) = self.parameterAsSink(parameters, self.OUTPUT,
                context, fields, QgsWkbTypes.LineString, moldura.sourceCrs())
        

        # Adicionando o multistepfeedback para poder mostrar na tela o carregamento
        multiStepFeedback = QgsProcessingMultiStepFeedback(6, feedback)
        multiStepFeedback.setCurrentStep(0)
        multiStepFeedback.setProgressText(self.tr("Verificando estrtutura"))

        # Criando um dicionário para colocar a feature como chave e os pontos que ela contém como valores
        dictFeatPontos = {}

        # Inicialmente iterando sobre as feições 
        for current, feature in enumerate(moldura.getFeatures()):
            # Se o usuário desejar cancelar o processo:
            if feedback.isCanceled():
                break
            
            # Colocando em uma lista os vértices presentes na moldura, para construir uma feature do tipo
            # LineString que possui esses vértices
            listaVertMoldura = list(feature.geometry().vertices())

            # Adicionando a feição da iteração como chave e o valor uma lista que será adicionado os pontos
            # presentes na feição:
            dictFeatPontos[feature] = []

            # Adicionando os vertices como Wkt na lista que possui a chave a feature
            for vertice in listaVertMoldura:
                dictFeatPontos[feature].append(vertice.asWkt())

        multiStepFeedback.setCurrentStep(1)
        
        # Criando a lista que irá receber o elemento x e o elemento y da coordenada
        xy = []

        # Criando uma lista para armazenar as coordenadas, temos: 
        coord = []
                
        # Agora será passado a iteração nas features com ela mesma, para analisar juntamento com o dicionário
        # com os pontos, para verificar se o ponto está em duas features.
        for current2, featBase in enumerate(moldura.getFeatures()):
            # Caso o usuário desejar poderá cancelar o processo
            if feedback.isCanceled():
                break
            for current3, featComp in enumerate(moldura.getFeatures()):
                # Se o índice das feições forem iguais sairá da iteração
                if featBase.id() == featComp.id():
                    continue
                # Iterando sobre os pontos presentes no dicionário para a feat (feature de base) 
                # da iteração que será dada como base
                # e será analisado com a featComp (feature de comparação)
                for ponto in dictFeatPontos[featBase]:
                    if ponto not in dictFeatPontos[featComp]:
                        continue
                    # Armazenando em tuplas (x, y) no lista 'coord' criada
                    x = float(ponto.split("(")[1].split(")")[0].split(" ")[0])
                    y = float(ponto.split("(")[1].split(")")[0].split(" ")[1])
                    coord.append((x, y))
            
            multiStepFeedback.setCurrentStep(1)
        
        multiStepFeedback.setCurrentStep(2)

        # Criando a lista para adicionar as linestrings do tipo Wkt()
        listaLineStrings = []
        
        # Criando o dicionário que vai receber as distâncias como chave e o ponto daquela distância
        dictDistPonto = {}

        # Iterando para ter no dicionário cada ponto com a distância dele a todos os outros:
        for ponto1 in coord:
            if ponto1 in dictDistPonto:
                continue
            dictDistPonto[ponto1] = {}
            for ponto2 in coord:
                if ponto1 == ponto2:
                    continue
                dist = ((ponto1[0]-ponto2[0]) ** 2 + (ponto1[1]-ponto2[1]) ** 2) ** (1/2)
                dictDistPonto[ponto1][dist] = ponto2

        # Colocando em ordem a lista das distâncias:
        for coordenada in coord:
            distOrdenada = sorted(dictDistPonto[coordenada])
            if distOrdenada[3] > distOrdenada[2] + 50:
                continue
            linestring = "LINESTRING (" + f"{coordenada[0]} " + f"{coordenada[1]}, " + f"{dictDistPonto[coordenada][distOrdenada[0]][0]} " + f"{dictDistPonto[coordenada][distOrdenada[0]][1]})"
            linestring1 = "LINESTRING (" + f"{coordenada[0]} " + f"{coordenada[1]}, " + f"{dictDistPonto[coordenada][distOrdenada[1]][0]} " + f"{dictDistPonto[coordenada][distOrdenada[1]][1]})"
            linestring2 = "LINESTRING (" + f"{coordenada[0]} " + f"{coordenada[1]}, " + f"{dictDistPonto[coordenada][distOrdenada[2]][0]} " + f"{dictDistPonto[coordenada][distOrdenada[2]][1]})"
            linestring3 = "LINESTRING (" + f"{coordenada[0]} " + f"{coordenada[1]}, " + f"{dictDistPonto[coordenada][distOrdenada[3]][0]} " + f"{dictDistPonto[coordenada][distOrdenada[3]][1]})"
            listaLineStrings.append(linestring)
            listaLineStrings.append(linestring1)
            listaLineStrings.append(linestring2)
            listaLineStrings.append(linestring3)
        
        # A lista das features:
        listaFeat = []
        for i in listaLineStrings:
            feat = QgsFeature()
            feat.setGeometry(QgsGeometry.fromWkt(i))

            if feat in listaFeat:
                continue
            listaFeat.append(feat)

        dictLineString = {}

        for current4, lineStringWkt in enumerate(listaLineStrings):
            # Caso o usuário deseje cancelar:
            if feedback.isCanceled():
                break

            # Adicionando o current4 como chave (id) e a feature correspondente como valor
            dictLineString[current4] = lineStringWkt
        
        # Criando um dicionário no qual colocaremos como chave o número da iteração (começando do zero) em relação 
        # a quantidade de camadas do tipo linestring passadas e o valor será uma lista que será composta de dois 
        # dicionários, o primeiro com a chave o id da feature e o valor como sendo a propria feature e o segundo dicionário
        # será o indice espacial
        dictListLayerIdSpatialIndex = {}

        for current5, camada in enumerate(listaCamadasPoligonos):
            if feedback.isCanceled():
                break

            # Criando o dicionário com chave sendo o id e o valor como a feição e o SpatialIndex
            dictIdFeat = {}
            spatialIndex = QgsSpatialIndex()

            # Iterando sobre as features da camada e formando assim o dicionário e o spatial index
            for featCamada in camada.getFeatures():
                dictIdFeat[featCamada.id()] = featCamada
                spatialIndex.addFeature(featCamada)

            # Colocando no dicionário que irá armazenar para todas as camadas passadas
            dictListLayerIdSpatialIndex[current5] = [dictIdFeat, spatialIndex]

        multiStepFeedback.setCurrentStep(4)

        for current6, idL in enumerate(list(dictLineString.keys())):
            # Caso o usuário deseje cancelar o processo:
            if feedback.isCanceled():
                break

            featL = QgsFeature()
            featL.setGeometry(QgsGeometry.fromWkt(dictLineString[idL]))

            geomL = featL.geometry().buffer(1/100, 200)
            bboxL = geomL.boundingBox()

            for i in range(len(list(dictListLayerIdSpatialIndex.keys()))):
                for idS in dictListLayerIdSpatialIndex[i][1].intersects(bboxL):
                    if dictListLayerIdSpatialIndex[i][0][idS].geometry().touches(featL.geometry()):
                        linha = dictListLayerIdSpatialIndex[i][0][idS].geometry().intersection(featL.geometry())
                        if "LineString" in linha.asWkt():
                            feedback.pushInfo(f"{linha.asWkt()}")
                            featSaida = QgsFeature()
                            featSaida.setGeometry(QgsGeometry.fromWkt(linha.asWkt()))

                            sink.addFeature(featSaida, QgsFeatureSink.FastInsert)
        
        multiStepFeedback.setCurrentStep(5)
        
        # A função retornará
        return {self.OUTPUT: dest_id}

    def name(self):
        """
        Returns the algorithm name, used for identifying the algorithm. This
        string should be fixed for the algorithm, and must not be localised.
        The name should be unique within each provider. Names should contain
        lowercase alphanumeric characters only and no spaces or other
        formatting characters.
        """
        return 'Solução Complementar do Projeto 4'

    def displayName(self):
        """
        Returns the translated algorithm name, which should be used for any
        user-visible display of the algorithm name.
        """
        return self.tr(self.name())

    def group(self):
        """
        Returns the name of the group this algorithm belongs to. This string
        should be localised.
        """
        return self.tr(self.groupId())

    def groupId(self):
        """
        Returns the unique ID of the group this algorithm belongs to. This
        string should be fixed for the algorithm, and must not be localised.
        The group id should be unique within each provider. Group id should
        contain lowercase alphanumeric characters only and no spaces or other
        formatting characters.
        """
        return 'Projeto 4'

    def tr(self, string):
        return QCoreApplication.translate('Processing', string)

    def createInstance(self):
        return Projeto4SolucaoComplementar()