# -*- coding: utf-8 -*-

"""
/***************************************************************************
 ProgramacaoAplicadaGrupo3
                                 A QGIS plugin
 Solução do Grupo 3
 Generated by Plugin Builder: http://g-sherman.github.io/Qgis-Plugin-Builder/
                              -------------------
        begin                : 2023-05-07
        copyright            : (C) 2023 by Grupo 3
        email                : matheus.silva@ime.eb.br
                               samuel.melo@ime.eb.br
                               reginaldo.filho@ime.eb.br
                               romeu.peris@ime.eb.br
 ***************************************************************************/

/***************************************************************************
 *                                                                         *
 *   This program is free software; you can redistribute it and/or modify  *
 *   it under the terms of the GNU General Public License as published by  *
 *   the Free Software Foundation; either version 2 of the License, or     *
 *   (at your option) any later version.                                   *
 *                                                                         *
 ***************************************************************************/
"""

__author__ = 'Grupo 3'
__date__ = '2023-03-20'
__copyright__ = '(C) 2023 by Grupo 3'

# This will get replaced with a git SHA1 when you do a git archive

__revision__ = '$Format:%H$'

from qgis.PyQt.QtCore import QCoreApplication, QVariant
from qgis.core import (QgsProcessing,
                       QgsFeatureSink,
                       QgsFeature,
                       QgsFields,
                       QgsSpatialIndex,
                       QgsProcessingParameterNumber,
                       QgsField,
                       QgsProcessingMultiStepFeedback,
                       QgsProcessingParameterMultipleLayers,
                       QgsGeometry,
                       QgsProcessing,
                       QgsWkbTypes,
                       QgsProcessingAlgorithm,
                       QgsProcessingParameterFeatureSource,
                       QgsProcessingParameterFeatureSink)
from collections import Counter



class Projeto4Solucao(QgsProcessingAlgorithm):
    """
    Tem por finalidade identificar os problemas com as feições que estão a um certo limite do buffer.
    """

    # Definindo os paramêtros que serão utilizados no processamento para a realização
    # do projeto

    # Definindo em uma variável o OUTPUT
    OUTPUT = 'OUTPUT'

    # Definindo em uma variável o INPUT_LINHAS, que será a lista das camadas do tipo linha
    INPUT_LINHAS = 'INPUT_LINHAS'

    # Definindo em uma variável o INPUT_MOLDURAS, que será o input da camada do tipo polígono
    INPUT_MOLDURA = 'INPUT_MOLDURA'

    # Definindo em uma variável o DISTANCIA_BUSCA, que será o valor do buffer na feature de linestring
    # da região que será procurada os erros
    DISTANCIA_BUSCA = 'DISTANCIA_BUSCA'

    def initAlgorithm(self, config):
        """
        Iniciando o algoritmo.
        """

        #  Adicionando o paramêtro da camada de entrada que será a moldura
        self.addParameter(
            QgsProcessingParameterFeatureSource(
                self.INPUT_MOLDURA,
                self.tr('Moldura'),
                [QgsProcessing.TypeVectorPolygon]
            )
        )
        
        # Adicionando o paramêtro da camada de entrada que será a lista das camadas do tipo linha, que serão
        # o ponto de analise desse projeto
        self.addParameter(
            QgsProcessingParameterMultipleLayers(
                self.INPUT_LINHAS,
                self.tr('Lista das camadas do tipo linha'),
                layerType = QgsProcessing.TypeVectorLine
            )
        )
        
        # Adicionando o paramêtro que é o responsável pelo buffer da parte central
        self.addParameter(
            QgsProcessingParameterNumber(
                self.DISTANCIA_BUSCA,
                self.tr('Distância de busca'),
                type=QgsProcessingParameterNumber.Double
            )
        )

        # Adicionando o paramêtro da camada de saída
        self.addParameter(
            QgsProcessingParameterFeatureSink(
                self.OUTPUT,
                self.tr('Camada de saída')
            )
        )
    

    def processAlgorithm(self, parameters, context, feedback):
        """
        Definindo o processamento do algoritmo
        """

        # Colocando na variável 'moldura' a camada de INPUT da moldura
        moldura = self.parameterAsSource(parameters, self.INPUT_MOLDURA, context)

        # Colocando na variável 'listaCamadasLinhas' a camada de INPUT das linhas
        listaCamadasLinhas = self.parameterAsLayerList(parameters, self.INPUT_LINHAS, context)

        # Colocando na variável 'distBusca' o número que vai receber de input (DISTANCIA_BUSCA)
        distBusca = self.parameterAsDouble(parameters, self.DISTANCIA_BUSCA, context)

        # Criando a variável que irá receber os atributos na tabela de atributo
        fields = QgsFields()
        # Adicionando o campo do tipo de string que irá receber a mensagem de erro
        fields.append(QgsField("tipo_de_erro", QVariant.String))

        # Colocando na variável a camada de saída
        (sink, dest_id) = self.parameterAsSink(parameters, self.OUTPUT,
                context, fields, QgsWkbTypes.Point, moldura.sourceCrs())
        

        # Adicionando o multistepfeedback para poder mostrar na tela o carregamento
        multiStepFeedback = QgsProcessingMultiStepFeedback(8, feedback)
        multiStepFeedback.setCurrentStep(0)
        multiStepFeedback.setProgressText(self.tr("Verificando estrtutura"))
        

        # Criando um dicionário para colocar a feature como chave e os pontos que ela contém como valores
        dictFeatPontos = {}

        # Inicialmente iterando sobre as feições 
        for current, feature in enumerate(moldura.getFeatures()):
            # Se o usuário desejar cancelar o processo:
            if feedback.isCanceled():
                break
            
            # Colocando em uma lista os vértices presentes na moldura, para construir uma feature do tipo
            # LineString que possui esses vértices
            listaVertMoldura = list(feature.geometry().vertices())

            # Adicionando a feição da iteração como chave e o valor uma lista que será adicionado os pontos
            # presentes na feição:
            dictFeatPontos[feature] = []

            # Adicionando os vertices como Wkt na lista que possui a chave a feature
            for vertice in listaVertMoldura:
                dictFeatPontos[feature].append(vertice.asWkt())

            feedback.pushInfo(f"{feature}")
        
        multiStepFeedback.setCurrentStep(1)
        
        # Criando a lista que irá receber o elemento x e o elemento y da coordenada
        xy = []

        # Criando uma lista para armazenar as coordenadas, temos: 
        coord = []
                
        # Agora será passado a iteração nas features com ela mesma, para analisar juntamento com o dicionário
        # com os pontos, para verificar se o ponto está em duas features.
        for current2, featBase in enumerate(moldura.getFeatures()):
            # Caso o usuário desejar poderá cancelar o processo
            if feedback.isCanceled():
                break
            for current3, featComp in enumerate(moldura.getFeatures()):
                # Se o índice das feições forem iguais sairá da iteração
                if featBase.id() == featComp.id():
                    continue
                # Iterando sobre os pontos presentes no dicionário para a feat (feature de base) 
                # da iteração que será dada como base
                # e será analisado com a featComp (feature de comparação)
                for ponto in dictFeatPontos[featBase]:
                    if ponto not in dictFeatPontos[featComp]:
                        continue
                    # Se o ponto estiver presente na lista (que é o valor da chave da feição) 
                    # ele será adicionado à lista dos pontos que pertencem a duas features da moldura
                    #stringCoord += ponto.split("(")[1].split(")")[0] + ", "
                    xy.append(ponto.split("(")[1].split(")")[0].split(" ")[0])
                    xy.append(ponto.split("(")[1].split(")")[0].split(" ")[1])
                    coord.append(ponto)
            
            multiStepFeedback.setCurrentStep(2)
        
        multiStepFeedback.setCurrentStep(3)
                    

        # Realizando o split na string de coordenadas para formar a LineString de dois pontos em sequência
        # temos:
        #listaCoord = stringCoord.split(", ")

        # Armazenando numa lista quais foram as coordenadas que se repetiram, que será nosso x e nosso y, temos:
        contador = Counter(xy)
        # A lista terá o termo em x que mais se repete que é responsável pela linha vertical da cruz 
        # e o termo y que mais se repete que é responsável pela linha horizontal da cruz
        repetidos = [
            item for item, quantidade in contador.items() 
            if quantidade > 4
        ]
        
        # Criando a lista para separar as coordenadas que estão em uma linha e na sua perpendicular:
        linha = []
        linhaPerp = []

        # Vamos percorrer a lista de pontos (coord) e analisar se a coordenada está no primeiro caso que
        # é ter o primeiro valor do repetido o segundo é ter o segundo valor repetido 
        for coordenada in coord:
            if repetidos[0] in coordenada:
                linha.append(coordenada)
            elif repetidos[1] in coordenada:
                linhaPerp.append(coordenada)

        # A linha é a linestring horizontal e linhaPerp é a linha vertical
        # Pegando para ordenar as coordenadas de y
        ordenLinha = []
        for coorde in linha:
            y = float(coorde.split("(")[1].split(")")[0].split(" ")[1])
            ordenLinha.append(y)

        # Pegando para ordenar as coordenadas de x
        ordenLinhaPerp = []
        for coorden in linhaPerp:
            y = float(coorden.split("(")[1].split(")")[0].split(" ")[0])
            ordenLinhaPerp.append(y)

        ordenLinhaPerp.append(float(repetidos[0]))

        # Criando a lista para adicionar as LineString que serão formadas com os pontos adjacentes
        ordenLinha = sorted(ordenLinha)
        ordenLinhaPerp = sorted(ordenLinhaPerp)

        # Linhas para adicionar a lineString
        lineCoordX = []
        for i in range(len(linha)):
            line = linha[i].split("(")[1].split(")")[0].split(" ")[0] + " " + f"{ordenLinha[i]}"
            lineCoordX.append(line)
        
        lineCoordY = []
        for j in range(len(linhaPerp)):
            line = f"{ordenLinhaPerp[j]}" + " " + linhaPerp[j].split("(")[1].split(")")[0].split(" ")[1]
            lineCoordY.append(line)
        
        # Criando a lista para adicionar os elementos de line string de forma wkt
        lineString = []
        
        # Adicionando as line string de cada pedaço da cruz
        for id in range(1, len(lineCoordX)):
            lineString.append("LINESTRING (" + lineCoordX[id - 1] + ", " + lineCoordX[id] + ")")
        
        for id in range(1, len(lineCoordY)):
            lineString.append("LINESTRING (" + lineCoordY[id - 1] + ", " + lineCoordY[id] + ")")
    
        dictLineString = {}

        for current4, lineStringWkt in enumerate(lineString):
            # Caso o usuário deseje cancelar:
            if feedback.isCanceled():
                break

            # Adicionando o current4 como chave (id) e a feature correspondente como valor
            dictLineString[current4] = lineStringWkt

        multiStepFeedback.setCurrentStep(3)

        # Criando um dicionário no qual colocaremos como chave o número da iteração (começando do zero) em relação 
        # a quantidade de camadas do tipo linestring passadas e o valor será uma lista que será composta de dois 
        # dicionários, o primeiro com a chave o id da feature e o valor como sendo a propria feature e o segundo dicionário
        # será o indice espacial
        dictListLayerIdSpatialIndex = {}

        for current5, camada in enumerate(listaCamadasLinhas):
            if feedback.isCanceled():
                break

            # Criando o dicionário com chave sendo o id e o valor como a feição e o SpatialIndex
            dictIdFeat = {}
            spatialIndex = QgsSpatialIndex()

            # Iterando sobre as features da camada e formando assim o dicionário e o spatial index
            for featCamada in camada.getFeatures():
                dictIdFeat[featCamada.id()] = featCamada
                spatialIndex.addFeature(featCamada)

            # Colocando no dicionário que irá armazenar para todas as camadas passadas
            dictListLayerIdSpatialIndex[current5] = [dictIdFeat, spatialIndex]
        
        multiStepFeedback.setCurrentStep(4)

        # Criando o dicionário para adicionar as features de cada camada que estão realizando a intersecção
        # sendo a chave o id e o valor sendo uma lista que irá receber o id das features:
        dictFeatIntersecta = {}

        for i in range(len(listaCamadasLinhas)):
            dictFeatIntersecta[i] = []

        pontoSaida = []

        # Iterando sobre as LineStrings da cruz central da moldura e aplicando o buffer que é igual ao dado
        # de entrada da distância da busca, para verificar as features das camadas do tipo linha passadas
        for current6, idLine in enumerate(list(dictLineString.keys())):
            # Caso o usuário deseje cancelar o processo:
            if feedback.isCanceled():
                break

            # Pegando a feat da line no dicionário, teremos:
            lineString = dictLineString[idLine]
            featLine = QgsFeature()
            featLine.setGeometry(QgsGeometry.fromWkt(lineString))
            geomLineBuf = featLine.geometry().buffer(distBusca / 100, 200) # geometria da linha do buffer para se conseguir o bounding box
            bboxLineBuf = geomLineBuf.boundingBox()

            # Será feito agora para tal bounding box a passagem em todas as camadas, analisando o contexto espacial
            for iteracao in range(len(listaCamadasLinhas)): # Mesmos índices que foram colocados de chave no dictListLayerIdSpatialIndex
                # Caso o usuário deseje cancelar o processo:
                if feedback.isCanceled():
                    break
                
                # Analisando pelo índice espacial quais features intersectam o buffer da linha na distância de busca
                for idSpatial in dictListLayerIdSpatialIndex[iteracao][1].intersects(bboxLineBuf):
                    # Então para o valor da iteração (iteracao) será adicionado a feature que intersecta 
                    # no dicionário criado dictFeatIntersecta

                    # Antes disso, analisando se a feature do indice espacial intersecta com 
                    # o buffer da geometria
                    if not geomLineBuf.intersection(dictListLayerIdSpatialIndex[iteracao][0][idSpatial].geometry()):
                        continue

                    dictFeatIntersecta[iteracao].append(idSpatial)
        
        multiStepFeedback.setCurrentStep(5)
        
        
        # Tendo posse do dicionário das features de cada camada do tipo linha que estão intersectando com o buffer
        # da da linha da moldura central, percorreremos agora a lista das features para cada camada e verificaremos 
        # se há duas features com os mesmos índices, o que ocasionou-se um erro, pois deveria ser apenas uma
        # feature.
        for current7, idC in enumerate(list(dictFeatIntersecta.keys())):
            # Caso o usuário deseje cancelar o processo:
            if feedback.isCanceled():
                break

            # Criando a variável para analisar o indice espacial entre as feições que tiveram a intersecção
            # com a linha
            spaInFeatInter = QgsSpatialIndex()
            for id in dictFeatIntersecta[idC]:
                # Pegando a feature do índice analise
                feat = dictListLayerIdSpatialIndex[idC][0][id]
                # Adicionando no contexto espacial
                spaInFeatInter.addFeature(feat)


            for idSpatBase in dictFeatIntersecta[idC]:
                # Pegando a feição do índice para analise, temos:
                featuresBase = dictListLayerIdSpatialIndex[idC][0][idSpatBase]
                # A geometria correspondente
                geomBase = featuresBase.geometry()
                # E consequentemente o boundingBox é dado por:
                bboxBase = geomBase.boundingBox()

                # Os índices espaciais das feições que intersectam a base é dado por
                for idInt in spaInFeatInter.intersects(bboxBase):
                    # Analisando se trata da mesma feição
                    if idInt == idSpatBase:
                        continue
                    
                    featuresComp = dictListLayerIdSpatialIndex[idC][0][idInt]
                    # Analisando se as feições se tocam
                    if featuresBase.geometry().touches(featuresComp.geometry()):
                        if featuresBase.attributes()[2:] == featuresComp.attributes()[2:]:
                            continue
                        # Pegando o ponto de toque das geometrias, temos:
                        pontoToque = featuresBase.geometry().intersection(featuresComp.geometry())

                        featSaida = QgsFeature(fields)
                        featSaida.setGeometry(QgsGeometry.fromWkt(pontoToque.asWkt()))
                        featSaida["tipo_de_erro"] = "Features conectadas com atributo diferente"

                        if featSaida in pontoSaida:
                            continue

                        pontoSaida.append(featSaida)

                        # Analisando se há intersecção entre a feature e a linestring da cruz central
                        # Inicialmente colocando a variável adicionar como 'False'
                        adicionar = False
                        for current8, idL in enumerate(list(dictLineString.keys())):
                            # se o usuário desejar cancelar o processo:
                            if feedback.isCanceled():
                                break
                            
                            # Analisando para o caso de todos os segmentos de linha, caso a feature intersecte com tal, 
                            # então a variável passará ser true
                            featL = QgsFeature()
                            featL.setGeometry(QgsGeometry.fromWkt(dictLineString[idL]))

                            if featL.geometry().intersection(featSaida.geometry()):
                                adicionar = True
                            
                        if adicionar:
                            # Adicionando na camada de saída
                            sink.addFeature(featSaida, QgsFeatureSink.FastInsert)
                        multiStepFeedback.setCurrentStep(7)

        multiStepFeedback.setCurrentStep(8)

        # Retorno dos resultados obtidos no processamento do algoritmo
        return {self.OUTPUT: dest_id}

    

    def name(self):
        """
        Retorna o nome do projeto
        """
        return 'Solução do Projeto 4'

    def displayName(self):
        """
        Returns the translated algorithm name, which should be used for any
        user-visible display of the algorithm name.
        """
        return self.tr(self.name())

    def group(self):
        """
        Returns the name of the group this algorithm belongs to. This string
        should be localised.
        """
        return self.tr(self.groupId())

    def groupId(self):
        """
        Returns the unique ID of the group this algorithm belongs to. This
        string should be fixed for the algorithm, and must not be localised.
        The group id should be unique within each provider. Group id should
        contain lowercase alphanumeric characters only and no spaces or other
        formatting characters.
        """
        return 'Projeto 4'

    def tr(self, string):
        return QCoreApplication.translate('Processing', string)

    def createInstance(self):
        return Projeto4Solucao()